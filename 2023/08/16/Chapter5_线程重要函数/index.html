<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>第五章：线程相关函数 | 江城子同学</title>
  
  <meta name="author" content="flyingfox" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="system programming" />
  
  <meta name="description" content="介绍线程相关的一些重要函数">
<meta property="og:type" content="article">
<meta property="og:title" content="第五章：线程相关函数">
<meta property="og:url" content="http://example.com/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="江城子同学">
<meta property="og:description" content="介绍线程相关的一些重要函数">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/images/thumbnail/thread-function.png">
<meta property="article:published_time" content="2023-08-16T10:36:59.000Z">
<meta property="article:modified_time" content="2023-08-21T10:17:53.024Z">
<meta property="article:author" content="flyingfox">
<meta property="article:tag" content="system programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/images/thumbnail/thread-function.png">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 6.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                        
                                            <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                        
                                    
                                        
                                            <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                        
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">江城子同学</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>江城子同学</h2> <br />
                        <span>十年饮冰，难凉热血</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">第五章：线程相关函数</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2023-08-16T10:36:59.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2023-08-16</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">flyingfox</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~22.11K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1692613073024"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-equal-3"><span class="toc-number">1.1.</span> <span class="toc-text">pthread_equal(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-self-3"><span class="toc-number">1.2.</span> <span class="toc-text">pthread_self(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-create-3"><span class="toc-number">2.1.</span> <span class="toc-text">pthread_create(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">3.</span> <span class="toc-text">线程的终止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-exit-3"><span class="toc-number">3.1.</span> <span class="toc-text">pthread_exit(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-join-3"><span class="toc-number">3.2.</span> <span class="toc-text">pthread_join(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">栈的清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cleanup-push-3"><span class="toc-number">4.1.</span> <span class="toc-text">pthread_cleanup_push(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cleanup-pop-3"><span class="toc-number">4.2.</span> <span class="toc-text">pthread_cleanup_pop(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">5.</span> <span class="toc-text">线程的取消</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cancel-3"><span class="toc-number">5.1.</span> <span class="toc-text">pthread_cancel(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-testcancel-3"><span class="toc-number">5.2.</span> <span class="toc-text">pthread_testcancel(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-setcancelstate-3"><span class="toc-number">5.3.</span> <span class="toc-text">pthread_setcancelstate(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-setcanceltype-3"><span class="toc-number">5.4.</span> <span class="toc-text">pthread_setcanceltype(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-detach-3"><span class="toc-number">5.5.</span> <span class="toc-text">pthread_detach(3)</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><p>介绍线程相关的一些重要函数</p>
<span id="more"></span>

<p>注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数）</p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>线程就是一个正在运行的函数。（进程就是容器，用来承载线程）</p>
<p>POSIX线程是一套标准，而不是实现。</p>
<p>线程标识：<code>pthread_t </code>中的”p”表示POSIX，数据类型不确定，因为各家实现不一样，有可能是整型，有可能是结构体，还有可能是typedef出来的指针类型。</p>
<p><code>ps axf</code>：查看进程关系</p>
<p><code>ps axm</code>：查看每个进程的线程</p>
<p><code>ps ax -L</code>：以列表形式查看进程与线程关系；</p>
<blockquote>
<p>  -L:    Show threads, possibly with LWP and NLWP columns.</p>
<p>   m:    Show threads after processes.</p>
</blockquote>
<p>信号机制和多线程机制可以在小范围内混用，不建议大范围内混用。</p>
<h3 id="pthread-equal-3"><a href="#pthread-equal-3" class="headerlink" title="pthread_equal(3)"></a>pthread_equal(3)</h3><p>在线程编程中，线程标识符是用来唯一标识一个线程的值，类似于进程ID（PID）用于唯一标识一个进程。pthread_equal() 函数用于比较两个线程标识符是否相等，从而判断两个线程是否是同一个线程。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>thread1</code>和<code>thread2</code>：两个线程标识符，类型为<code>pthread_t</code>。这两个参数将被用来比较是否表示同一个线程。</li>
</ul>
<p>函数返回值：</p>
<ul>
<li>如果<code>thread1</code>和<code>thread2</code>表示同一个线程，函数返回值为非零值（通常为1）。</li>
<li>如果<code>thread1</code>和<code>thread2</code>表示不同的线程，函数返回值为0。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>pthread_equal() 函数可以用来检查两个线程标识符是否相等，但并不是所有情况下都需要使用它。大多数情况下，你不需要直接比较线程标识符，而是通过线程同步机制来确保线程之间的正确协作。</li>
<li>在实际编程中，尽量避免直接使用 pthread_equal() 来做逻辑判断，因为它可能会引入不必要的复杂性和风险。更好的方法是使用互斥锁、条件变量等线程同步机制来控制线程的执行顺序和协作。</li>
</ul>
<h3 id="pthread-self-3"><a href="#pthread-self-3" class="headerlink" title="pthread_self(3)"></a>pthread_self(3)</h3><p>pthread_self() 函数用于获取当前调用线程的线程标识符。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>函数返回值：</p>
<ul>
<li>返回值是一个<code>pthread_t</code> 类型的值，表示调用线程的线程标识符。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>pthread_self() 函数返回的线程标识符是一个内部表示，通常是一个指针或数字。在不同的操作系统和编译器中，它可能采用不同的方式来表示线程标识符。因此，最好不要将线程标识符作为具体的数值来进行比较或操作。</li>
</ul>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="pthread-create-3"><a href="#pthread-create-3" class="headerlink" title="pthread_create(3)"></a>pthread_create(3)</h3><p>pthread_create()函数用于创建一个新的线程，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>thread</code>：指向 pthread_t 类型变量的指针，用于保存新线程的标识符。</li>
<li><code>attr</code>：指向 pthread_attr_t 类型变量的指针，用于指定新线程的属性，例如线程的栈大小、线程优先级等。如果为 NULL，则使用默认线程属性。</li>
<li><code>start_routine</code>：线程函数的指针，<strong>新线程将从这个函数开始执行</strong>。</li>
<li><code>arg</code>：传递给线程函数的参数。</li>
</ul>
<p>函数返回值：</p>
<p>若成功，返回0；否则，返回错误编号（error number）。</p>
<blockquote>
<p>  <em>On  success,  pthread_create()  returns  0; on error, it returns an error number, and the contents of *thread are undefined.</em> （man手册）</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_create.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The thread is working.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ gcc pthread_create.c -pthread</span><br><span class="line">$ ./a.out</span><br><span class="line">Begin!</span><br><span class="line">End!</span><br><span class="line">$ ./a.out</span><br><span class="line">Begin!</span><br><span class="line">End!</span><br><span class="line">The thread is working.</span><br><span class="line">The thread is working.</span><br><span class="line">$ ./a.out</span><br><span class="line">Begin!</span><br><span class="line">End!</span><br><span class="line">The thread is working.</span><br></pre></td></tr></table></figure>

<p>注：线程的调度取决于调度器策略</p>
<p>编译也可以通过包含以下内容的makefile文件来实现：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br></pre></td></tr></table></figure>

<p>不用写成类似于<code>gcc pthread_create.c -pthread</code>，直接<code>make pthread_create</code>即可。</p>
<p>线程的终止：</p>
<p>（1）线程从启动例程返回，返回值就是线程的退出码；</p>
<p>（2）线程可以被同一进程中的其他线程取消；</p>
<p>（3）线程调用pthread_exit()函数；（该函数会结束调用线程）</p>
<p>【man手册：】</p>
<p>The new thread terminates in one of the following ways:</p>
<ul>
<li><p>It calls pthread_exit(3), specifying an exit status value that is available to another thread in the same process that calls pthread_join(3).</p>
</li>
<li><p>It returns from start_routine().  This is equivalent to calling pthread_exit(3) with the value supplied in the return statement.</p>
</li>
<li><p>It is canceled (see pthread_cancel(3)).</p>
</li>
<li><p>Any of the threads in the process calls exit(3), or the main thread performs a return from main().  This causes the termination of all threads in the process.</p>
</li>
</ul>
<h2 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h2><h3 id="pthread-exit-3"><a href="#pthread-exit-3" class="headerlink" title="pthread_exit(3)"></a>pthread_exit(3)</h3><p>pthread_exit()函数用于终止当前线程的执行，并返回一个退出状态给线程的调用者。它允许线程在完成任务或遇到特定条件时自行终止，而不影响其他线程。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>retval</code>：一个指向任意类型数据的指针，表示线程的退出状态。在多线程环境下，线程的退出状态可以是一个任意类型的数据，用于向其他线程传递信息。</li>
</ul>
<p>注意事项：</p>
<ol>
<li>使用 pthread_exit() 函数可以避免线程突然终止，从而防止线程资源泄漏和未完成的操作。</li>
<li>在调用 pthread_exit() 函数之后，当前线程会立即终止，并不会执行 pthread_join() 函数等待其他线程完成。</li>
<li>被终止的线程的资源会被系统回收，但其他线程仍会继续运行。</li>
<li>在多线程程序中，如果某个线程使用 pthread_exit() 终止了，整个程序可能还会继续执行，直到所有线程都完成或被终止。</li>
</ol>
<p>举个栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = *((<span class="type">int</span> *)arg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d started.\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Thread [%d]: %d\n&quot;</span>, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d finished.\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret1, ret2;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">3</span>, n2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ret1 = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, &amp;n1);</span><br><span class="line">    <span class="keyword">if</span> (ret1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(ret1));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ret2 = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_func, &amp;n2);</span><br><span class="line">    <span class="keyword">if</span> (ret2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(ret2));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread finished.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread 3 started.</span><br><span class="line">  Thread [3]: 0</span><br><span class="line">  Thread [3]: 1</span><br><span class="line">  Thread [3]: 2</span><br><span class="line">Thread 3 finished.</span><br><span class="line">Thread 5 started.</span><br><span class="line">  Thread [5]: 0</span><br><span class="line">  Thread [5]: 1</span><br><span class="line">  Thread [5]: 2</span><br><span class="line">  Thread [5]: 3</span><br><span class="line">  Thread [5]: 4</span><br><span class="line">Thread 5 finished.</span><br><span class="line">Main thread finished.</span><br></pre></td></tr></table></figure>

<h3 id="pthread-join-3"><a href="#pthread-join-3" class="headerlink" title="pthread_join(3)"></a>pthread_join(3)</h3><p>pthread_join()函数用于等待指定的线程结束，并获取它的退出状态。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>thread</code>：要等待的线程的标识符，通常是通过调用 pthread_create() 函数创建的线程。</li>
<li><code>retval</code>：一个指向指针的指针，用于存储被等待线程的退出状态。这个参数允许线程传递一个指向任意数据类型的指针作为退出状态。</li>
</ul>
<p>函数返回值：</p>
<blockquote>
<p>  <em>On success, pthread_join() returns 0; on error, it returns an error number.</em></p>
</blockquote>
<p>注意事项：</p>
<ol>
<li>如果不关心线程的退出状态，可以将 retval 参数设置为 NULL。</li>
<li>如果指定的线程已经结束，那么 pthread_join() 函数会立即返回，并返回 0 作为函数值。如果指定的线程还未结束，那么 pthread_join() 函数会一直阻塞，直到线程结束为止。</li>
</ol>
<p>注：pthread_join()函数功能类似于wait()函数，收尸。</p>
<p>在多线程编程中，线程的退出状态通常用来表示线程的执行结果，可以通过 pthread_exit() 函数返回给线程的调用者，或者通过 pthread_join() 函数获取。在某些情况下，我们可能需要在线程中传递一些复杂的数据结构，如<strong>结构体</strong>、<strong>指针</strong>等，来描述线程的执行结果。此时，我们可以将这些数据结构作为指针传递给线程函数，让线程函数负责修改这些数据结构，并通过 pthread_exit() 函数或全局变量等方式将其返回给线程的调用者。</p>
<p>举个栗子：</p>
<p>以下是一个简单的例子，演示如何在线程中传递指针来描述线程的执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125; ThreadData;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadData *data = (ThreadData *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d started.\n&quot;</span>, data-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟线程执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= data-&gt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  Thread %d: %d\n&quot;</span>, data-&gt;id, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据结构的值</span></span><br><span class="line">    data-&gt;count *= data-&gt;count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回线程的退出状态</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret1, ret2;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    ThreadData data1 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, data2 = &#123;<span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个新线程</span></span><br><span class="line">    ret1 = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, &amp;data1);</span><br><span class="line">    ret2 = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_func, &amp;data2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret1 != <span class="number">0</span> || ret2 != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create threads!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread 1 count: %d\n&quot;</span>, data1.count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread 2 count: %d\n&quot;</span>, data2.count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread finished.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 started.</span><br><span class="line">  Thread 1: 1</span><br><span class="line">  Thread 1: 2</span><br><span class="line">  Thread 1: 3</span><br><span class="line">Thread 2 started.</span><br><span class="line">  Thread 2: 1</span><br><span class="line">  Thread 2: 2</span><br><span class="line">  Thread 2: 3</span><br><span class="line">  Thread 2: 4</span><br><span class="line">  Thread 2: 5</span><br><span class="line">Thread 1 count: 9</span><br><span class="line">Thread 2 count: 25</span><br><span class="line">Main thread finished.</span><br></pre></td></tr></table></figure>

<h2 id="栈的清理"><a href="#栈的清理" class="headerlink" title="栈的清理"></a>栈的清理</h2><p>pthread_cleanup_push()，pthread_cleanup_pop() 都是宏，作用类似于钩子函数。</p>
<p>注：<code>gcc xxx.c -E</code>可以判断xxx.c文件中哪些是宏&#x2F;条件编译，预处理后剩下的内容。</p>
<blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>void pthread_cleanup_push(void (*routine)(void *), void *arg);</em></p>
<p>  ​       <em>void pthread_cleanup_pop(int execute);</em></p>
<p>  ​       <em>Compile and link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>These  functions  manipulate the calling thread’s stack of thread-cancellation clean-up handlers.  A clean-up handler is a function that is automatically executed when a thread is canceled (or in various other circumstances described below); it might,  for  example, unlock a mutex so that it becomes available to other threads in the process.</em></p>
<p>  ​       <em>The  pthread_cleanup_push() function pushes routine onto the top of the stack of clean-up handlers.  When routine is later invoked, it will be given arg as its argument.</em></p>
<p>  ​       <em>The pthread_cleanup_pop() function removes the routine at the top of the stack of clean-up handlers, and optionally executes it  if execute is nonzero.</em></p>
<p>  ​       <em>A cancellation clean-up handler is popped from the stack and executed in the following circumstances:</em></p>
<p>  ​       <em>1. When  a  thread  is  canceled, all of the stacked clean-up handlers are popped and executed in the reverse of the order in which they were pushed onto the stack.</em></p>
<p>  ​       <em>2. When a thread terminates by calling pthread_exit(3), all clean-up handlers are executed as described  in  the  preceding  point. (Clean-up handlers are not called if the thread terminates by performing a return from the thread start function.)</em></p>
<p>  ​       <em>3. When a thread calls pthread_cleanup_pop() with a nonzero execute argument, the top-most clean-up handler is popped and executed.</em></p>
<p>  ​       <em>POSIX.1 permits pthread_cleanup_push() and pthread_cleanup_pop() to be implemented as macros that expand to text containing ‘{‘ and ‘}’, respectively.  For this reason, the caller must ensure that calls to these functions are paired within the same function,  and at  the  same  lexical  nesting level.  (In other words, a clean-up handler is established only during the execution of a specified section of code.)</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>These functions do not return a value.</em></p>
</blockquote>
<p>在指定的代码段执行期间才会建立清理处理程序。在执行过程中，可以使用 pthread_cleanup_push() 函数将清理处理程序压入堆栈，并在代码段执行结束时使用 pthread_cleanup_pop() 函数将其弹出。<u>这种机制确保了清理处理程序只在特定代码段的执行过程中存在，并在其执行结束后自动弹出。</u>这种机制在多线程编程中非常有用，可以确保线程在任何情况下都能够正常地终止并释放资源。</p>
<h3 id="pthread-cleanup-push-3"><a href="#pthread-cleanup-push-3" class="headerlink" title="pthread_cleanup_push(3)"></a>pthread_cleanup_push(3)</h3><p>pthread_cleanup_push() 函数用于为线程设置清理处理程序（clean-up handler）。该函数可以将一个清理处理程序绑定到线程，当线程退出时，清理处理程序会被调用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>routine</code>：一个函数指针，指向清理处理程序函数，这个函数在线程退出时会被调用。它的原型应该是 <code>void function_name(void *arg)</code>。</li>
<li><code>arg</code>：传递给清理处理程序函数的参数，类型是<code>void *</code>。这可以是指向某个资源或状态的指针，以便在清理处理程序中进行适当的操作。</li>
</ul>
<h3 id="pthread-cleanup-pop-3"><a href="#pthread-cleanup-pop-3" class="headerlink" title="pthread_cleanup_pop(3)"></a>pthread_cleanup_pop(3)</h3><p>pthread_cleanup_pop() 函数用于指定清理处理程序的执行条件。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>execute</code>：一个整数值，用于指定是否执行清理处理程序。非零值表示执行，零值表示不执行。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>pthread_cleanup_push() 函数必须与 pthread_cleanup_pop() 成对使用。每次调用 pthread_cleanup_push() 函数都应该紧接着调用相应的 pthread_cleanup_pop() 函数。</li>
<li>当线程调用pthread_exit()、pthread_cancel()、pthread_cleanup_pop() 或者线程函数返回时，绑定在该线程上的清理处理程序会被按照它们被创建时的相反顺序执行。</li>
<li>清理处理程序的执行条件是由线程库在特定条件下自动执行的，而不是由线程程序员显式调用的。清理处理程序通常用于资源释放、内存清理等工作，以确保在线程退出时不会造成资源泄漏。</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cleanup.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The thread is working!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:1&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:2&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;push over!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin.&quot;</span>);</span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ make cleanup</span><br><span class="line">cc -pthread  -pthread  cleanup.c   -o cleanup</span><br><span class="line">$ ./cleanup </span><br><span class="line">Begin.</span><br><span class="line">The thread is working!</span><br><span class="line">push over!</span><br><span class="line">cleanup:3</span><br><span class="line">cleanup:2</span><br><span class="line">cleanup:1</span><br><span class="line">End.</span><br></pre></td></tr></table></figure>

<h2 id="线程的取消"><a href="#线程的取消" class="headerlink" title="线程的取消"></a>线程的取消</h2><h3 id="pthread-cancel-3"><a href="#pthread-cancel-3" class="headerlink" title="pthread_cancel(3)"></a>pthread_cancel(3)</h3><p>注：要结束正在运行的线程，先把线程取消，再收尸。就跟wait()函数给进程收尸一样，正在运行的内容是没办法收尸收回来的。</p>
<p>调用 pthread_cancel() 函数会向指定的线程发送取消请求，但并不保证该线程会立即退出，而是在接下来的某个取消点（cancellation point）执行取消操作。线程会在适当的时候检查取消请求，并调用相应的清理处理函数。这些清理处理函数可以通过调用 pthread_cleanup_push() 和 pthread_cleanup_pop() 函数来注册。</p>
<blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>pthread_cancel -</em> <em>send a cancellation request to a thread</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>int pthread_cancel(pthread_t thread);</em></p>
<p>  ​       <em>Compile and link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>The  pthread_cancel()  function sends a cancellation request to the thread thread.  Whether and when the target thread reacts to the cancellation request depends on two  attributes  that  are under the control of that thread: its cancelability state and type.</em></p>
<p>  ​       <em>A  thread’s  cancelability  state, determined by pthread_setcancelstate(3), can be enabled (the default for new threads) or disabled.  If a thread has disabled cancellation, then a  cancellation  request  remains  queued  until the thread enables cancellation.  If a thread has enabled cancellation, then its cancelability type determines when cancellation occurs.</em></p>
<p>  ​       <em>A thread’s cancellation type, determined by pthread_setcanceltype(3), may be  either  asynchronous  or  deferred  (the  default  for new threads). Asynchronous cancelability means that the thread can be canceled at any time (usually immediately, but  the  system  does  not  guarantee this).   Deferred  cancelability  means that cancellation will be delayed until the thread next calls a function that is a cancellation point.  A list of functions that are or may be  cancellation points is provided in pthreads(7).</em></p>
<p>  ​       <em>When  a  cancellation  requested  is  acted  on,  the following steps occur for thread (in this order):</em></p>
<p>  ​       <em>1. Cancellation clean-up handlers are popped (in the reverse of the order in  which  they  were pushed) and called.  (See pthread_cleanup_push(3).)</em></p>
<p>  ​       <em>2. Thread-specific data destructors are called, in an unspecified order.  (See pthread_key_create(3).)</em></p>
<p>  ​       <em>3. The thread is terminated.  (See pthread_exit(3).)</em></p>
<p>  ​       <em>The above steps happen asynchronously with respect to the pthread_cancel()  call;  the  return status  of pthread_cancel() merely informs the caller whether the cancellation request was successfully queued.</em></p>
<p>  ​       <em>After a canceled thread has terminated, a join with that thread using  pthread_join(3)  obtains PTHREAD_CANCELED  as  the thread’s exit status.  (Joining with a thread is the only way to know that cancellation has completed.)</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>On success, pthread_cancel() returns 0; on error, it returns a nonzero error number.</em></p>
</blockquote>
<p>取消有2种状态：允许和不允许。</p>
<p>允许取消可分为：异步cancel；推迟cancel（默认）-&gt; 推迟至cancel点再响应</p>
<p>cancel点：<strong>POSIX定义的cancel点，都是可能引发阻塞的系统调用</strong>。而非系统调用的内容是不是cancel点，各个平台定义有所区别。</p>
<p>注意事项：</p>
<ul>
<li>pthread_cancel() 函数并不保证线程会立即终止，而是发送一个取消请求。实际的取消发生可能会受到线程当前的状态和取消点的影响。</li>
<li>线程可以选择是否响应取消请求，它可以在取消点进行响应，也可以选择忽略取消请求。</li>
<li>线程可以通过调用pthread_setcancelstate() 函数来设置线程是否允许取消，以及在取消点是否响应取消。</li>
</ul>
<p>举个栗子：</p>
<p>以下代码片段中，如果在第一次open()操作执行成功后，第二次open()操作执行前被中断，那close()操作将无法执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open();</span><br><span class="line"><span class="keyword">if</span>(fd1 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd2 = open();</span><br><span class="line"><span class="keyword">if</span>(fd2 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd1);</span><br><span class="line">close(fd2);</span><br></pre></td></tr></table></figure>

<p>可以挂钩子函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open();</span><br><span class="line"><span class="keyword">if</span>(fd1 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        ----&gt; pthread_cleanup_push();   -&gt; close(fd1);</span><br><span class="line"></span><br><span class="line">fd2 = open();</span><br><span class="line"><span class="keyword">if</span>(fd2 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        ----&gt; pthread_cleanup_push();   -&gt; close(fd2);</span><br></pre></td></tr></table></figure>

<p>如果前面成功了，但刚好在挂钩子函数之前就被取消了，这种情况是不会发生的。</p>
<h3 id="pthread-testcancel-3"><a href="#pthread-testcancel-3" class="headerlink" title="pthread_testcancel(3)"></a>pthread_testcancel(3)</h3><blockquote>
<p>  <em><strong>NAME</strong></em><br>         <em>pthread_testcancel - request delivery of any pending cancellation request</em></p>
<p>  <em><strong>SYNOPSIS</strong></em><br>         <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>void pthread_testcancel(void);</em></p>
<p>  ​       <em>Compile and link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em><br>         <em>Calling  pthread_testcancel()  creates a cancellation point within the calling thread, so that a thread that is otherwise executing code that contains no cancellation points will respond to a cancellation request.</em></p>
<p>  ​       <em>If cancelability is disabled (using pthread_setcancelstate(3)), or no cancellation request is pending, then a call to pthread_testcancel() has no effect.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em><br>         <em>This function does not return a value.  If the calling thread is canceled as a consequence of a call to this function, then the function does not return.</em></p>
</blockquote>
<p>注：在多线程编程中，取消请求是用来请求终止一个线程的操作，但是实际终止时间是由线程在取消点检查取消请求后决定的。</p>
<p>pthread_testcancel() 函数通常被用作取消点（cancellation point），检查是否有取消请求被发送。如果有取消请求，则线程会在此处终止执行，之后的代码将不再执行。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_testcancel</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>在程序中使用pthread_testcancel() 函数时，通常需要与pthread_setcancelstate() 函数和pthread_setcanceltype() 函数一起使用，以确保线程在取消点检查取消请求。</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread is running...\n&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_testcancel(); 	<span class="comment">// 作为取消点，检查取消请求</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此后的代码不会被执行，因为在取消点检查到取消请求后线程会终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);	<span class="comment">// 让线程运行一段时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送取消请求</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_cancel(tid) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_cancel&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Main thread <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，pthread_testcancel() 函数被用作取消点，用于在线程中检查是否有取消请求。在调用这个函数后，如果有取消请求，线程将终止。</p>
<h3 id="pthread-setcancelstate-3"><a href="#pthread-setcancelstate-3" class="headerlink" title="pthread_setcancelstate(3)"></a>pthread_setcancelstate(3)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>pthread_setcancelstate, pthread_setcanceltype -</em> <em>set cancelability state and type</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>int pthread_setcancelstate(int state, int *oldstate);</em></p>
<p>  ​       <em>int pthread_setcanceltype(int type, int *oldtype);</em></p>
<p>  ​       <em>Compile and link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>The  pthread_setcancelstate()  sets  the cancelability state of the calling thread to the value given in state.  The previous cancelability state of the  thread  is  returned  in  the  buffer pointed to by oldstate.  The state argument must have one of the following values:</em></p>
<p>  ​       <em><strong>PTHREAD_CANCEL_ENABLE</strong></em>  <em>The  thread  is cancelable.  This is the default cancelability state in all new threads, including the initial thread.  The thread’s cancelability type determines when a  cancelable thread will respond to a cancellation request.</em></p>
<p>  ​       <em><strong>PTHREAD_CANCEL_DISABLE</strong></em>  <em>The  thread  is  not  cancelable.   If a cancellation request is received, it is blocked until cancelability is enabled.</em></p>
<p>  ​       <em>The pthread_setcanceltype() sets the cancelability type of the  calling  thread  to  the  value given in type.  The previous cancelability type of the thread is returned in the buffer pointed to by oldtype.  The type argument must have one of the following values:</em></p>
<p>  ​       <em><strong>PTHREAD_CANCEL_DEFERRED</strong></em>  <em>A cancellation request is deferred until the thread next calls a function that is a cancellation  point  (see  pthreads(7)).  This is the default cancelability type in all new threads, including the initial thread.</em></p>
<p>  ​       <em><strong>PTHREAD_CANCEL_ASYNCHRONOUS</strong></em>  <em>The thread can be canceled at any time.  (Typically, it  will  be  canceled  immediately upon receiving a cancellation request, but the system doesn’t guarantee this.)</em></p>
<p>  ​       <em>The  set-and-get operation performed by each of these functions is atomic with respect to other threads in the process calling the same function.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>On success, these functions return 0; on error, they return a nonzero error number.</em></p>
</blockquote>
<p>pthread_setcancelstate() 函数用于设置线程的取消状态。线程可以设置是否允许取消请求（cancellation request）对其进行取消。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>state</code>：一个整数值，表示要设置的取消状态。可以是以下值之一：<ul>
<li><strong>PTHREAD_CANCEL_ENABLE</strong>：允许取消请求（<u>默认值</u>）。</li>
<li><strong>PTHREAD_CANCEL_DISABLE</strong>：禁止取消请求。</li>
</ul>
</li>
<li><code>oldstate</code>：一个指向整数的指针，用于存储之前的取消状态。如果不关心之前的状态，可以将此参数设置为 NULL。</li>
</ul>
<p>函数返回值：</p>
<ul>
<li>若成功设置取消状态，函数返回值为0；若发生错误，返回一个非零的错误码。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>取消状态仅影响线程是否对取消请求进行响应，实际的取消点和取消类型也会影响线程的终止。</li>
<li>在调用 pthread_create() 创建线程之前，可以使用 pthread_setcancelstate() 来设置线程的取消状态。</li>
</ul>
<h3 id="pthread-setcanceltype-3"><a href="#pthread-setcanceltype-3" class="headerlink" title="pthread_setcanceltype(3)"></a>pthread_setcanceltype(3)</h3><p>pthread_setcanceltype() 函数用于设置线程的取消类型。线程的取消类型决定了在取消点检查取消请求时，线程如何响应取消请求。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>type</code>：一个整数值，表示要设置的取消类型。可以是以下值之一：<ul>
<li><strong>PTHREAD_CANCEL_ASYNCHRONOUS</strong>：立即响应取消请求。</li>
<li><strong>PTHREAD_CANCEL_DEFERRED</strong>：只有在下一个取消点时响应取消请求（<u>默认值</u>）。</li>
</ul>
</li>
<li><code>oldtype</code>：一个指向整数的指针，用于存储之前的取消类型。如果不关心之前的类型，可以将此参数设置为 NULL。</li>
</ul>
<p>函数返回值：</p>
<ul>
<li>若成功设置取消类型，函数返回值为0；若发生错误，返回一个非零的错误码。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>取消类型会影响线程在取消点检查取消请求时的响应，以及线程是否会在取消点终止执行。</li>
<li>在调用 pthread_create() 创建线程之前，可以使用 pthread_setcanceltype() 来设置线程的取消类型。</li>
</ul>
<h3 id="pthread-detach-3"><a href="#pthread-detach-3" class="headerlink" title="pthread_detach(3)"></a>pthread_detach(3)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>pthread_detach - detach a thread</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>int pthread_detach(pthread_t thread);</em></p>
<p>  ​       <em>Compile and link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>The  pthread_detach() function marks the thread identified by thread as detached.  When a detached thread terminates, its resources are automatically released back to the system without the need for another thread to join with the terminated thread.</em></p>
<p>  ​       <em>Attempting to detach an already detached thread results in unspecified behavior.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>On success, pthread_detach() returns 0; on error, it returns an error number.</em></p>
<p>  <em><strong>ERRORS</strong></em></p>
<p>  ​       <em><strong>EINVAL</strong></em> <em>thread is not a joinable thread.</em></p>
<p>  ​       <em><strong>ESRCH</strong></em>  <em>No thread with the ID thread could be found.</em></p>
</blockquote>
<p>在线程编程中，有两种状态：分离状态和非分离状态。分离状态的线程在退出后会自动释放资源，而非分离状态的线程需要通过pthread_join() 来获取返回值并释放资源。</p>
<p>pthread_detach() 函数用于将一个线程标记为“分离状态”，从而使得线程在退出时能够自动释放其资源，无需显式调用 pthread_join() 来等待其它线程获取返回值。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>thread</code>：要被标记为分离状态的线程的标识符，类型为<code>pthread_t</code>。</li>
</ul>
<p>函数返回值：</p>
<ul>
<li>若成功将线程标记为分离状态，函数返回值为0；若发生错误，返回一个非零的错误码。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>只能对还没有被其他线程调用 pthread_join() 的线程进行分离操作。</li>
<li>在线程标记为分离状态之后，不能再次对其进行分离或者非分离操作。</li>
</ul>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/";
            const title         = "「第五章：线程相关函数」";
            const excerpt       = `介绍线程相关的一些重要函数`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/system-programming/" rel="tag">system programming</a>
                </div>
                <div class="pull-date">
                    <time datetime="2023-08-21T10:17:53.024Z" itemprop="dateModified">最后编辑：2023-08-21</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 第五章：线程同步机制" href="/2023/08/15/Chapter5_线程同步机制/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" 解析命令行参数" href="/2023/08/17/命令行参数的分析/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.png" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                18
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                5
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                8
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-equal-3"><span class="toc-text">pthread_equal(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-self-3"><span class="toc-text">pthread_self(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-create-3"><span class="toc-text">pthread_create(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-text">线程的终止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-exit-3"><span class="toc-text">pthread_exit(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-join-3"><span class="toc-text">pthread_join(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-text">栈的清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cleanup-push-3"><span class="toc-text">pthread_cleanup_push(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cleanup-pop-3"><span class="toc-text">pthread_cleanup_pop(3)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-text">线程的取消</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cancel-3"><span class="toc-text">pthread_cancel(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-testcancel-3"><span class="toc-text">pthread_testcancel(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-setcancelstate-3"><span class="toc-text">pthread_setcancelstate(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-setcanceltype-3"><span class="toc-text">pthread_setcanceltype(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-detach-3"><span class="toc-text">pthread_detach(3)</span></a></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Exercise/">Exercise</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/">《系统编程实践（C语言版）》</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E6%BF%80%E6%B4%BB/">软件激活</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/BurpSuite/" style="font-size: 0.6em;">BurpSuite</a> <a href="/tags/DynELF/" style="font-size: 0.6em;">DynELF</a> <a href="/tags/ELF/" style="font-size: 0.6em;">ELF</a> <a href="/tags/SQL%E6%B3%A8%E5%85%A5/" style="font-size: 0.6em;">SQL注入</a> <a href="/tags/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/" style="font-size: 0.6em;">SSH免密登录</a> <a href="/tags/system-programming/" style="font-size: 0.8em;">system programming</a> <a href="/tags/%E5%85%B1%E4%BA%AB%E5%BA%93/" style="font-size: 0.6em;">共享库</a> <a href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" style="font-size: 0.6em;">动态链接</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2023/09/07/%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8mpg123%E6%92%AD%E6%94%BE%E6%AD%8C%E6%9B%B2/"><i class="fa  fa-book"></i> 子进程调用mpg123播放歌曲</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/09/01/Chapter7_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fa  fa-book"></i> 第七章：网络编程</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/25/Chapter6_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><i class="fa  fa-book"></i> 第六章：进程间通信</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/"><i class="fa  fa-book"></i> 第三章：进程</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/18/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"><i class="fa  fa-book"></i> 钩子函数|进程的终止方式</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 江城子同学 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by flyingfox.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                    <div class="box theme-box" id="snow-switch">
                        <span class="fa fa-snowflake-o"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>

    <div>
        <canvas id="snow"></canvas>
        <script async src="/js/snow.min.js"></script>
    </div>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>