<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>第五章：线程同步机制 | 江城子同学</title>
  
  <meta name="author" content="flyingfox" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="system programming" />
  
  <meta name="description" content="主要介绍线程同步的三种方式：互斥量、条件变量、信号量">
<meta property="og:type" content="article">
<meta property="og:title" content="第五章：线程同步机制">
<meta property="og:url" content="http://example.com/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="江城子同学">
<meta property="og:description" content="主要介绍线程同步的三种方式：互斥量、条件变量、信号量">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/images/thumbnail/thread-mysem.png">
<meta property="article:published_time" content="2023-08-15T10:36:59.000Z">
<meta property="article:modified_time" content="2023-08-22T08:02:38.015Z">
<meta property="article:author" content="flyingfox">
<meta property="article:tag" content="system programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/images/thumbnail/thread-mysem.png">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 6.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                        
                                            <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                        
                                    
                                        
                                            <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                        
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">江城子同学</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>江城子同学</h2> <br />
                        <span>十年饮冰，难凉热血</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">第五章：线程同步机制</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2023-08-15T10:36:59.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2023-08-15</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">flyingfox</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~23.42K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1692691358015"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89"><span class="toc-number">1.</span> <span class="toc-text">线程竞争</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">互斥量的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%8A%A0%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">对临界区加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="toc-number">2.3.</span> <span class="toc-text">举个栗子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">条件变量的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">等待条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.3.</span> <span class="toc-text">发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90-1"><span class="toc-number">3.4.</span> <span class="toc-text">举个栗子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-init-3"><span class="toc-number">4.1.</span> <span class="toc-text">sem_init(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-destroy-3"><span class="toc-number">4.2.</span> <span class="toc-text">sem_destroy(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-wait-3"><span class="toc-number">4.3.</span> <span class="toc-text">sem_wait(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-post-3"><span class="toc-number">4.4.</span> <span class="toc-text">sem_post(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90%E3%80%90%E4%BA%92%E6%96%A5%E9%87%8F-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E5%8D%95%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%91"><span class="toc-number">4.5.</span> <span class="toc-text">举个栗子【互斥量+条件变量 -&gt; 单个信号量】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F-VS-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-VS-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">互斥量 VS 条件变量 VS 信号量</span></a></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><p>主要介绍线程同步的三种方式：互斥量、条件变量、信号量</p>
<span id="more"></span>

<p>注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数）</p>
<h2 id="线程竞争"><a href="#线程竞争" class="headerlink" title="线程竞争"></a>线程竞争</h2><p>使用20个线程分别对同一个文件进行如下操作：打开，读取数据，加1，覆盖写回去，关闭文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(buf, BUFSIZE, fp);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %d\n&quot;</span>, atoi(buf) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d\n&quot;</span>, atoi(buf) + <span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_func, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某次编译运行的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ cat /tmp/out</span><br><span class="line"><span class="number">0</span></span><br><span class="line">$ make add</span><br><span class="line">cc -pthread  -pthread  add.c   -o add</span><br><span class="line">$ ./add</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  <span class="number">5</span></span><br><span class="line">  <span class="number">6</span></span><br><span class="line">  <span class="number">7</span></span><br><span class="line">  <span class="number">8</span></span><br><span class="line">  <span class="number">9</span></span><br><span class="line">  <span class="number">10</span></span><br><span class="line">  <span class="number">9</span></span><br><span class="line">  <span class="number">10</span></span><br><span class="line">  <span class="number">11</span></span><br><span class="line">  <span class="number">11</span></span><br><span class="line">  <span class="number">12</span></span><br><span class="line">  <span class="number">13</span></span><br><span class="line">  <span class="number">14</span></span><br><span class="line">  <span class="number">14</span></span><br><span class="line">  <span class="number">15</span></span><br><span class="line">$ cat /tmp/out</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>多个线程同时对同一个文件进行读写操作，如果线程之间没有进行同步操作，可能导致文件中的数据错乱或者不确定的结果，因为对文件的读写操作不一定是原子的。</p>
<p>多线程的并发操作中，往往需要使用线程同步机制来保护对<strong>共享资源</strong>（如文件）的访问，以避免数据竞争和不确定的结果。</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>互斥量（mutex，mutual exclusion）是一种用于线程同步的机制，它可以用来保护共享资源的访问。在多线程程序中，多个线程可能同时访问同一个共享资源，如果没有同步机制，就会导致竞争条件（race condition）的问题，从而导致程序出现不可预期的错误。互斥量可以用来解决这个问题，它可以实现对共享资源的互斥访问，保证同一时刻只有一个线程可以访问共享资源。<u>通俗点说，互斥量就是限制一段代码以读的形式实现</u>。</p>
<p>互斥量可以看作是一个特殊的变量，它有两种状态：锁定（locked）和未锁定（unlocked），只有获得锁的线程才能访问共享资源，其他线程需要等待锁的释放才能继续执行。一个线程可以通过尝试加锁来获得互斥量，如果互斥量当前处于未锁定状态，则该线程可以获得锁并进入临界区；如果互斥量已经被锁定，则该线程会被阻塞等待互斥量的释放。当线程进入临界区时，互斥量被锁定；当线程离开临界区时，互斥量被释放。</p>
<p>基本用法如下：</p>
<p>1.<strong>定义互斥量变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure>

<p>2.<strong>初始化互斥量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>3.<strong>对临界区加锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 访问共享资源</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>4.<strong>销毁互斥量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>互斥量的另一个重要特性是递归锁，也叫做可重入锁。当一个线程已经获得了互斥量的锁，并在临界区内执行时，如果再次尝试获得该互斥量的锁，则不会被阻塞，而是继续执行。这种情况下，互斥量被称为递归锁，因为同一个线程可以多次获得该锁。</p>
<h3 id="互斥量的初始化"><a href="#互斥量的初始化" class="headerlink" title="互斥量的初始化"></a>互斥量的初始化</h3><p>动态初始化和静态初始化放在不同环境中使用，如果是凭空定义出来的变量，用静态初始化更简单些，直接使用默认属性就行，如果当前互斥量是位于结构体中的，用动态方式初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;	<span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;	<span class="comment">// 动态初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="对临界区加锁"><a href="#对临界区加锁" class="headerlink" title="对临界区加锁"></a>对临界区加锁</h3><p>把同一时刻只能一个线程来访问的那部分共享资源称为临界区。在进入临界区前lock，退出临界区后unlock，互斥量锁住的是一段代码，而非仅仅指一个变量、函数之类的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>注：pthread_mutex_lock()是阻塞的，pthread_mutex_trylock()是非阻塞的。</p>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>前面的add.c程序，如果是20个线程同时只读是ok的，但是如果这段代码同时运行着20份，某个线程在执行读操作时，别的线程在执行写操作，那就可能出错。</p>
<p>上述add.c程序加入互斥量机制后的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add_mutex.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    fp = fopen(FNAME, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fgets(buf, BUFSIZE, fp);</span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="comment">// printf(&quot;  %d\n&quot;, atoi(buf) + 1);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d\n&quot;</span>, atoi(buf) + <span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_func, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="number">0</span> &gt; /tmp/out</span><br><span class="line">$ cat /tmp/out</span><br><span class="line"><span class="number">0</span></span><br><span class="line">$ make add_mutex</span><br><span class="line">cc -pthread  -pthread  add_mutex.c   -o add_mutex</span><br><span class="line">$ ./add_mutex </span><br><span class="line">$ cat /tmp/out</span><br><span class="line"><span class="number">20</span></span><br><span class="line">$ ./add_mutex </span><br><span class="line">$ cat /tmp/out</span><br><span class="line"><span class="number">40</span></span><br><span class="line">$ ./add_mutex </span><br><span class="line">$ cat /tmp/out</span><br><span class="line"><span class="number">60</span></span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>在线程同步中，条件变量是一种用于线程间通信的机制。它是一种同步原语，用于在一个或多个线程等待某个条件的发生时，使其进入阻塞状态，等待其他线程发出条件变量的信号，使其解除阻塞。</p>
<p>条件变量通常与互斥锁结合使用，以实现线程间的同步和互斥。通常，一个或多个线程在等待某个条件的发生时，会先获得互斥锁，然后通过条件变量进入阻塞状态。在其他线程满足条件时，会发送信号给条件变量，然后解除阻塞状态，继续执行。</p>
<p>条件变量本身不是一个锁，它只是一个等待队列，用于线程之间的通信。线程可以在条件变量上等待某个条件的发生，当条件满足时，其他线程可以通过条件变量来通知等待的线程，从而使得等待的线程重新开始执行。</p>
<p>在使用条件变量时，通常需要注意以下几点：</p>
<ul>
<li>需要先获得互斥锁，然后再使用条件变量。这可以避免多个线程同时访问共享变量，造成数据不一致的问题。</li>
<li>等待条件时，需要在 while 循环中检查条件是否满足，以避免虚假唤醒的问题。</li>
<li>发送信号时，可以使用 signal 或 broadcast 两种方式。signal 只会唤醒一个等待该条件的线程，而 broadcast 则会唤醒所有等待该条件的线程。</li>
</ul>
<p>通常，使用条件变量需要以下步骤：</p>
<p>1.定义条件变量和互斥量变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br></pre></td></tr></table></figure>

<p>2.初始化条件变量和互斥量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>3.在等待条件时使用条件变量和互斥量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 条件已满足，执行相应操作</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>4.在条件满足时使用条件变量和互斥量发送信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">condition = <span class="number">1</span>;</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>5.销毁条件变量和互斥量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_destroy(&amp;cond);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用条件变量时，需要避免竞争条件的问题，并且要确保发送信号的线程和等待条件的线程使用的是同一个互斥量。否则，可能会导致死锁或其他错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (condition_not_satisfied) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<h3 id="条件变量的初始化"><a href="#条件变量的初始化" class="headerlink" title="条件变量的初始化"></a>条件变量的初始化</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>pthread_cond_destroy, pthread_cond_init — destroy and initialize condition variables</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>int pthread_cond_destroy(pthread_cond_t *cond);</em></p>
<p>  ​       <em>int pthread_cond_init(pthread_cond_t *restrict cond,</em></p>
<p>  ​           <em>const pthread_condattr_t *restrict attr);</em></p>
<p>  ​       <em>pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>If successful, the pthread_cond_destroy() and pthread_cond_init() functions shall  return  zero; otherwise, an error number shall be returned to indicate the error.</em></p>
</blockquote>
<h3 id="等待条件"><a href="#等待条件" class="headerlink" title="等待条件"></a>等待条件</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>pthread_cond_timedwait, pthread_cond_wait —</em> <em>wait on a condition</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>int pthread_cond_timedwait(pthread_cond_t *restrict cond,</em></p>
<p>  ​           <em>pthread_mutex_t *restrict mutex,</em></p>
<p>  ​           <em>const struct timespec *restrict abstime);</em></p>
<p>  ​       <em>int pthread_cond_wait(pthread_cond_t *restrict cond,</em></p>
<p>  ​           <em>pthread_mutex_t *restrict mutex);</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  <em>Except for [ETIMEDOUT], [ENOTRECOVERABLE], and [EOWNERDEAD], all these error checks shall act as if  they  were  performed  immediately at the beginning of processing for the function and shall cause an error return, in effect, prior to modifying the state of the mutex specified  by  mutex or the condition variable specified by cond.</em></p>
<p>  <em>Upon  successful completion, a value of zero shall be returned; otherwise, an error number shall be returned to indicate the error.</em></p>
</blockquote>
<p>pthread_cond_wait：让当前线程等待在条件变量 cond 上。该函数需要传递两个参数：一个 pthread_cond_t 类型的指针，表示需要等待的条件变量；一个 pthread_mutex_t 类型的指针，表示需要使用的互斥锁。该函数会自动释放互斥锁，并将当前线程置于等待条件的队列中，直到收到信号或被中断为止。【<strong>解锁等待</strong>】</p>
<p>如果多个线程等待同一个条件变量，当条件变量被 pthread_cond_signal() 唤醒时，只有一个线程会被唤醒；当条件变量被 pthread_cond_broadcast() 唤醒时，所有等待的线程都会被唤醒。此函数返回 0 表示成功，其他值表示出现错误。</p>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>在多线程编程中，线程之间可能需要同步，例如等待某个条件变量（cond）满足才能继续执行。当一个线程发现条件满足时，它可以通过调用 pthread_cond_signal() 或者 pthread_cond_broadcast() ，向正在等待该条件变量的其他线程发送信号。</p>
<blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>pthread_cond_broadcast, pthread_cond_signal —</em> <em>broadcast or signal a condition</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;pthread.h&gt;</em></p>
<p>  ​       <em>int pthread_cond_broadcast(pthread_cond_t *cond);</em></p>
<p>  ​       <em>int pthread_cond_signal(pthread_cond_t *cond);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>These functions shall unblock threads blocked on a condition variable.</em></p>
<p>  ​       <em>The  pthread_cond_broadcast() function shall unblock</em> <em>all</em> <em>threads currently blocked on the specified condition variable cond.</em></p>
<p>  ​       <em>The pthread_cond_signal() function shall unblock</em> <em>at least one</em> <em>of the threads that are blocked on the specified condition variable cond (if any threads are blocked on cond).</em></p>
<p>  ​       <em>If  more  than one thread is blocked on a condition variable, the scheduling policy shall determine the order in which threads are unblocked. When each thread  unblocked  as  a  result  of  a pthread_cond_broadcast()  or  pthread_cond_signal() returns from its call to pthread_cond_wait() or  pthread_cond_timedwait(),  the  thread  shall  own  the   mutex   with   which   it   called pthread_cond_wait() or pthread_cond_timedwait().  The thread(s) that are unblocked shall contend for the mutex according to the scheduling policy (if applicable), and  as  if  each  had  called pthread_mutex_lock().</em></p>
<p>  ​       <em>The  pthread_cond_broadcast()  or  pthread_cond_signal()  functions  may  be  called by a thread whether or not  it  currently  owns  the  mutex  that  threads  calling  pthread_cond_wait()  or pthread_cond_timedwait()  have  associated  with the condition variable during their waits; however, if predictable scheduling behavior is required, then that mutex shall  be  locked  by  the thread calling pthread_cond_broadcast() or pthread_cond_signal().</em></p>
<p>  ​       <em>The  pthread_cond_broadcast()  and pthread_cond_signal() functions shall have no effect if there are no threads currently blocked on cond.</em></p>
<p>  ​       <em>The behavior is undefined if the value specified by the  cond  argument  to pthread_cond_broadcast() or pthread_cond_signal() does not refer to an initialized condition variable.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>If  successful,  the  pthread_cond_broadcast()  and pthread_cond_signal() functions shall return zero; otherwise, an error number shall be returned to indicate the error.</em></p>
</blockquote>
<p>pthread_cond_signal()是唤醒一个等待，pthread_cond_broadcast()唤醒多个等待。</p>
<h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>在一个程序中创建四个线程，使之分别向终端输出a,b,c,d，要求能连续的输出abcd字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abcd.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n + <span class="number">1</span> == THRNUM)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">intptr_t</span>)p;</span><br><span class="line">    <span class="type">int</span> ch = <span class="string">&#x27;a&#x27;</span> + n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut);</span><br><span class="line">        <span class="keyword">while</span> (num != n)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mut);</span><br><span class="line">        write(<span class="number">1</span>, &amp;ch, <span class="number">1</span>);</span><br><span class="line">        num = next(num);</span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, err;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)(<span class="type">intptr_t</span>)i);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>当资源在一定范围内可以共享时，互斥量就不太好用了。互斥量是以独占的方式来使用。</p>
<p>信号量（Semaphore）是一个同步原语，用于控制多线程或多进程对共享资源的访问。信号量是一个整数值，通常表示共享资源的可用数量。信号量提供了两个基本操作：等待（wait，又称为P操作）和释放（post，又称为V操作）。</p>
<ol>
<li>等待（wait，P操作）: 当一个线程或进程执行等待操作时，信号量的值减一。如果信号量的值在操作之后为负数，执行等待操作的线程将被阻塞，直到信号量的值变为非负数。</li>
<li>释放（post，V操作）: 当一个线程或进程执行释放操作时，信号量的值加一。如果有其他线程或进程在等待信号量，其中一个被阻塞的线程将被唤醒，并允许继续执行。</li>
</ol>
<p>信号量可以用于实现多种同步和协调机制，例如：</p>
<ol>
<li>互斥访问共享资源: 当信号量的初始值设置为1时，它可以用于实现互斥（mutex）。在这种情况下，执行等待操作的线程将获得对共享资源的独占访问，而其他尝试访问该资源的线程将被阻塞，直到释放操作执行。</li>
<li>同步线程或进程: 当信号量的初始值设置为0时，它可以用于同步线程或进程。例如，一个线程可以在完成某个任务后执行释放操作，而另一个线程可以执行等待操作，等待任务完成。这样可以确保第二个线程在第一个线程完成任务之后才开始执行。</li>
<li>限制对共享资源的并发访问: 当信号量的初始值设置为大于1的整数时，它可以用于限制对共享资源的并发访问。这种情况下，信号量的值表示可以同时访问共享资源的线程或进程的最大数量。</li>
</ol>
<p>信号量在不同的系统和编程语言中有不同的实现。例如，在Unix系统中，信号量可以通过System V IPC或POSIX IPC实现。在C语言中，可以使用POSIX线程库（pthread）提供的信号量函数，如<strong>sem_init</strong>、<strong>sem_wait</strong>、<strong>sem_post</strong>和<strong>sem_destroy</strong>。</p>
<blockquote>
<p>  注：下面函数的参数 <strong>sem</strong> 都是指向已初始化的 <strong>sem_t</strong> 类型变量的指针</p>
<p>  1.<strong>int sem_init(sem_t *sem, int pshared, unsigned int value);</strong> 函数 <strong>sem_init</strong> 用于初始化一个信号量。<strong>sem</strong> 用于存储初始化后的信号量；参数 <strong>pshared</strong> 决定信号量是用于线程间同步（设置为0）还是进程间同步（设置为非0）；参数 <strong>value</strong> 是信号量的初始值。</p>
<p>  成功时，函数返回 0；失败时返回 -1，并设置 errno。</p>
<p>  2.<strong>int sem_destroy(sem_t *sem);</strong> 函数 <strong>sem_destroy</strong> 用于销毁一个信号量，释放其相关资源。</p>
<p>  成功时，函数返回 0；失败时返回 -1，并设置 errno。</p>
<p>  3.<strong>int sem_wait(sem_t *sem);</strong> 函数 <strong>sem_wait</strong> 用于以原子操作的方式减少信号量的值。如果信号量的值大于 0，它将减少信号量的值并立即返回。如果信号量的值为 0，则调用线程将阻塞，直到信号量的值变为正数。</p>
<p>  成功时，函数返回 0；失败时返回 -1，并设置 errno。</p>
<p>  4.<strong>int sem_post(sem_t *sem);</strong> 函数 <strong>sem_post</strong> 用于以原子操作的方式增加信号量的值。如果有其他线程因为 <strong>sem_wait</strong> 被阻塞在该信号量上，它们将被唤醒。</p>
<p>  成功时，函数返回 0；失败时返回 -1，并设置 errno。</p>
</blockquote>
<h3 id="sem-init-3"><a href="#sem-init-3" class="headerlink" title="sem_init(3)"></a>sem_init(3)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>sem_init - initialize an unnamed semaphore</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;semaphore.h&gt;</em></p>
<p>  ​       <em>int sem_init(sem_t *sem, int pshared, unsigned int value);</em></p>
<p>  ​       <em>Link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>sem_init()  initializes the unnamed semaphore at the address pointed to by sem.  The value argument specifies the initial value  for  the semaphore.</em></p>
<p>  ​       <em>The pshared  argument  indicates  whether  this  semaphore is to be shared between the threads of a process, or between processes.</em></p>
<p>  ​       <em>If pshared has the value 0, then the semaphore is shared between the threads  of a process, and should be located at some address that is visible to all threads (e.g., a global variable, or a variable allocated dynamically on the heap).</em></p>
<p>  ​       <em>If  pshared  is  nonzero,  then the semaphore is shared between processes, and should be located in a  region  of  shared  memory  (see shm_open(3),  mmap(2),  and  shmget(2)).   (Since a child created by fork(2) inherits its parent’s memory mappings, it  can  also  access the  semaphore.)   Any process that can access the shared memory region can operate on the semaphore  using sem_post(3),  sem_wait(3), and so on.</em></p>
<p>  ​       <em>Initializing  a  semaphore that has already been initialized results in undefined behavior.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>sem_init() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error.</em></p>
</blockquote>
<h3 id="sem-destroy-3"><a href="#sem-destroy-3" class="headerlink" title="sem_destroy(3)"></a>sem_destroy(3)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>sem_destroy -</em> <em>destroy an unnamed semaphore</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;semaphore.h&gt;</em></p>
<p>  ​       <em>int sem_destroy(sem_t *sem);</em></p>
<p>  ​       <em>Link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>sem_destroy() destroys the unnamed semaphore at the address pointed to by sem.</em></p>
<p>  ​       <em>Only  a  semaphore  that  has  been initialized by sem_init(3) should be destroyed using sem_destroy().</em></p>
<p>  ​       <em>Destroying a semaphore that other processes or threads are currently blocked on (in sem_wait(3)) produces undefined behavior.</em></p>
<p>  ​       <em>Using  a  semaphore  that has been destroyed produces undefined results, until the semaphore has been reinitialized using sem_init(3).</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>sem_destroy() returns 0 on success; on error, -1 is returned, and</em> <em>errno</em> <em>is set to  indicate  the error.</em></p>
<p>  <em><strong>ERRORS</strong></em></p>
<p>  ​       <em><strong>EINVAL</strong></em> <em>sem</em> <em>is not a valid semaphore.</em></p>
</blockquote>
<h3 id="sem-wait-3"><a href="#sem-wait-3" class="headerlink" title="sem_wait(3)"></a>sem_wait(3)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>sem_wait, sem_timedwait, sem_trywait - lock a semaphore</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;semaphore.h&gt;</em></p>
<p>  ​       <em>int sem_wait(sem_t *sem);</em></p>
<p>  ​       <em>int sem_trywait(sem_t *sem);</em></p>
<p>  ​       <em>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</em></p>
<p>  ​       <em>Link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>sem_wait()  decrements  (locks)  the  semaphore  pointed to by sem.  If the semaphore’s value is greater than zero, then the decrement proceeds, and the function returns, immediately.   If  the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal  handler  interrupts the call.</em></p>
<p>  ​       <em>sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking.</em></p>
<p>  ​       <em>sem_timedwait() is the same as sem_wait(), except that abs_timeout  specifies  a  limit  on  the amount of time that the call should block if the decrement cannot be immediately performed.  The abs_timeout argument points to a structure that specifies an absolute  timeout  in  seconds  and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This structure is defined as follows:</em></p>
<p>  ​           <em>struct timespec {</em></p>
<p>  ​               <em>time_t tv_sec;      &#x2F;* Seconds *&#x2F;</em></p>
<p>  ​               <em>long   tv_nsec;     &#x2F;* Nanoseconds [0 .. 999999999] *&#x2F;</em></p>
<p>  ​           <em>};</em></p>
<p>  ​       <em>If the timeout has already expired by the time of the call,  and  the  semaphore  could  not  be locked immediately, then sem_timedwait() fails with a timeout error (errno set to ETIMEDOUT).</em></p>
<p>  ​       <em>If  the  operation can be performed immediately, then sem_timedwait() never fails with a timeout error, regardless of the value of abs_timeout.  Furthermore, the validity of abs_timeout is  not checked in this case.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>All  of  these  functions  return 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error.</em></p>
</blockquote>
<h3 id="sem-post-3"><a href="#sem-post-3" class="headerlink" title="sem_post(3)"></a>sem_post(3)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>sem_post -</em> <em>unlock a semaphore</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;semaphore.h&gt;</em></p>
<p>  ​       <em>int sem_post(sem_t *sem);</em></p>
<p>  ​       <em>Link with -pthread.</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>sem_post()  increments (unlocks) the semaphore pointed to by sem.  If the semaphore’s value consequently becomes greater than zero, then another process or thread  blocked  in  a  sem_wait(3) call will be woken up and proceed to lock the semaphore. 释放信号量，将信号量的值加 1.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>sem_post()  returns  0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error.</em></p>
</blockquote>
<h3 id="举个栗子【互斥量-条件变量-单个信号量】"><a href="#举个栗子【互斥量-条件变量-单个信号量】" class="headerlink" title="举个栗子【互斥量+条件变量 -&gt; 单个信号量】"></a>举个栗子【互斥量+条件变量 -&gt; 单个信号量】</h3><p>使用互斥量+条件变量完成一个可以记次数（有资源上限）的资源共享。使用信号量机制重构之前的计算质数的程序（primer.c）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysem.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSEM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSEM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="type">mysem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">mysem_t</span> *<span class="title function_">mysem_init</span><span class="params">(<span class="type">int</span> initval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_add</span><span class="params">(<span class="type">mysem_t</span> *, <span class="type">int</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_sub</span><span class="params">(<span class="type">mysem_t</span> *, <span class="type">int</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_destroy</span><span class="params">(<span class="type">mysem_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysem.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义信号量结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mut;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义信号量初始值</span></span><br><span class="line"><span class="type">mysem_t</span> *<span class="title function_">mysem_init</span><span class="params">(<span class="type">int</span> initval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    me-&gt;value = initval;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_add</span><span class="params">(<span class="type">mysem_t</span> *ptr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    me-&gt;value += n;</span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该先判断n的值大于0还是小于0；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_sub</span><span class="params">(<span class="type">mysem_t</span> *ptr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">while</span> (me-&gt;value &lt; n)</span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond, &amp;me-&gt;mut);</span><br><span class="line">    me-&gt;value -= n;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_destroy</span><span class="params">(<span class="type">mysem_t</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    <span class="built_in">free</span>(me); <span class="comment">// free(ptr);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT    30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT   30000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THRNUM  (RIGHT-LEFT+1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N       4           <span class="comment">// 线程个数(信号量的初始值)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">mysem_t</span> *sem;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_primer</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,err;</span><br><span class="line">    <span class="type">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    sem = mysem_init(N);</span><br><span class="line">    <span class="keyword">if</span>(sem == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;mysem_init() failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mysem_sub(sem, <span class="number">1</span>);</span><br><span class="line">        err = pthread_create(tid+(i-LEFT),<span class="literal">NULL</span>,thread_primer,(<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create():%s\n&quot;</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysem_destroy(sem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_primer</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,mark;</span><br><span class="line">    i = (<span class="type">int</span>)p;</span><br><span class="line"></span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt;= i/<span class="number">2</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    mysem_add(sem, <span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// makefile</span><br><span class="line"></span><br><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br><span class="line"></span><br><span class="line"><span class="section">all:mysem</span></span><br><span class="line"></span><br><span class="line"><span class="section">mysem:main.o mysem.o</span></span><br><span class="line">    gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o mysem</span><br></pre></td></tr></table></figure>

<p>运行.&#x2F;mysem程序后，通过ps ax -L指令可看到类似于如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PID     LWP TTY      STAT   TIME COMMAND</span><br><span class="line">5021    5021 pts/4    Sl+    0:00 ./mysem</span><br><span class="line">5021    5148 pts/4    Sl+    0:00 ./mysem</span><br><span class="line">5021    5149 pts/4    Sl+    0:00 ./mysem</span><br><span class="line">5021    5150 pts/4    Sl+    0:00 ./mysem</span><br><span class="line">5021    5151 pts/4    Sl+    0:00 ./mysem</span><br></pre></td></tr></table></figure>

<p>反复执行，5021进程一直在，后面的4个线程会变。</p>
<p>后面介绍进程间通信时，会介绍信号量数组，相当于这个模型的放大，如果把信号量存在数组或指针当中，就成了mytb或anytimer的一个实现套路。封装的mytb库是解决问题常用的一个框架。</p>
<p>补充：在vim中使用快捷键进行字符串替换操作，将全文中的mytbf字符串都替换为mysem。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br><span class="line"></span><br><span class="line"><span class="section">all:mytbf</span></span><br><span class="line"></span><br><span class="line"><span class="section">mytbf:main.o mytbf.o</span></span><br><span class="line">    gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf *.o mytbf</span><br></pre></td></tr></table></figure>

<p>:%s&#x2F;mytbf&#x2F;mysem&#x2F;g	将每一行中的所有mytbf替换为mysem</p>
<p>:%s&#x2F;mytbf&#x2F;mysem		将每一行中的第一个mytbf替换为mysem</p>
<p>:s&#x2F;mytbf&#x2F;mysem&#x2F;g		将当前行中的所有mytbf替换为mysem</p>
<h2 id="互斥量-VS-条件变量-VS-信号量"><a href="#互斥量-VS-条件变量-VS-信号量" class="headerlink" title="互斥量 VS 条件变量 VS 信号量"></a>互斥量 VS 条件变量 VS 信号量</h2><p>互斥量（Mutex）、条件变量（Condition Variable）和信号量（Semaphore）是用于同步和协调多线程或多进程之间的执行的常见工具。它们之间的主要区别如下：</p>
<ol>
<li>互斥量（Mutex）: <strong>互斥量主要用于保护共享资源的访问，确保同一时刻只有一个线程或进程可以访问共享资源</strong>。互斥量的基本操作包括加锁（lock）和解锁（unlock）。当一个线程获取互斥量时，其他线程必须等待直到互斥量被释放。互斥量通常用于实现临界区，即一段只能被一个线程执行的代码。</li>
<li>条件变量（Condition Variable）: <strong>条件变量用于线程间的同步，它允许一个或多个线程等待满足某个条件</strong>。条件变量通常与互斥量一起使用，当一个线程需要等待某个条件时，它会解锁互斥量并阻塞在条件变量上，当条件满足时，另一个线程可以使用条件变量通知等待的线程，此时，被唤醒的线程会重新获取互斥量并继续执行。条件变量的主要操作有：等待（wait）、通知一个（signal）和通知所有（broadcast）。</li>
<li>信号量（Semaphore）: <strong>信号量是一个计数器，用于控制对共享资源的访问</strong>。信号量有两个基本操作：等待（wait，又称为P操作）和释放（post，又称为V操作）。当一个线程执行等待操作时，信号量的值减一，如果此时信号量的值小于零，线程会阻塞。当一个线程执行释放操作时，信号量的值加一，如果有其他线程在等待该信号量，其中一个线程将被唤醒。信号量可以用于实现互斥（当信号量的初始值为1时）和同步（当信号量的初始值为0时）。</li>
</ol>
<p>总结：</p>
<ul>
<li>互斥量主要用于保护共享资源，确保同一时刻只有一个线程可以访问该资源。</li>
<li>条件变量用于线程间同步，允许线程等待某个条件满足。</li>
<li>信号量用于控制对共享资源的访问，可实现互斥和同步。</li>
</ul>
<p>互斥量和条件变量通常用于多线程编程，而信号量可以用于多线程和多进程编程。在某些系统中，信号量实现可能基于互斥量和条件变量。</p>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/";
            const title         = "「第五章：线程同步机制」";
            const excerpt       = `主要介绍线程同步的三种方式：互斥量、条件变量、信号量`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/system-programming/" rel="tag">system programming</a>
                </div>
                <div class="pull-date">
                    <time datetime="2023-08-22T08:02:38.015Z" itemprop="dateModified">最后编辑：2023-08-22</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 第一章：输入输出" href="/2023/07/27/Chapter1_IO/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" 第五章：线程相关函数" href="/2023/08/16/Chapter5_线程重要函数/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.png" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                16
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                5
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                7
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89"><span class="toc-text">线程竞争</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">互斥量的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%8A%A0%E9%94%81"><span class="toc-text">对临界区加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="toc-text">举个栗子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">条件变量的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-text">等待条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90-1"><span class="toc-text">举个栗子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-init-3"><span class="toc-text">sem_init(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-destroy-3"><span class="toc-text">sem_destroy(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-wait-3"><span class="toc-text">sem_wait(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sem-post-3"><span class="toc-text">sem_post(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90%E3%80%90%E4%BA%92%E6%96%A5%E9%87%8F-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E5%8D%95%E4%B8%AA%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%91"><span class="toc-text">举个栗子【互斥量+条件变量 -&gt; 单个信号量】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F-VS-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-VS-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">互斥量 VS 条件变量 VS 信号量</span></a></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SQL%E6%B3%A8%E5%85%A5/">SQL注入</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/">《系统编程实践（C语言版）》</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E6%BF%80%E6%B4%BB/">软件激活</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/BurpSuite/" style="font-size: 0.6em;">BurpSuite</a> <a href="/tags/DynELF/" style="font-size: 0.6em;">DynELF</a> <a href="/tags/ELF/" style="font-size: 0.6em;">ELF</a> <a href="/tags/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/" style="font-size: 0.6em;">SSH免密登录</a> <a href="/tags/system-programming/" style="font-size: 0.8em;">system programming</a> <a href="/tags/%E5%85%B1%E4%BA%AB%E5%BA%93/" style="font-size: 0.6em;">共享库</a> <a href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" style="font-size: 0.6em;">动态链接</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2023/08/25/Chapter6_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><i class="fa  fa-book"></i> 第六章：进程间通信</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/"><i class="fa  fa-book"></i> 第三章：进程</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/18/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"><i class="fa  fa-book"></i> 钩子函数|进程的终止方式</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/17/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90/"><i class="fa  fa-book"></i> 解析命令行参数</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/"><i class="fa  fa-book"></i> 第五章：线程相关函数</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 江城子同学 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by flyingfox.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                    <div class="box theme-box" id="snow-switch">
                        <span class="fa fa-snowflake-o"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>

    <div>
        <canvas id="snow"></canvas>
        <script async src="/js/snow.min.js"></script>
    </div>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>