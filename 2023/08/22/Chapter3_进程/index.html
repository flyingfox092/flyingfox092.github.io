<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>第三章：进程 | 江城子同学</title>
  
  <meta name="author" content="flyingfox" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="system programming" />
  
  <meta name="description" content="主要介绍（1）搭建UNIX世界框架的三个函数：fork()，wait()以及exec函数族；（2）守护进程；（3）系统日志">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章：进程">
<meta property="og:url" content="http://example.com/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="江城子同学">
<meta property="og:description" content="主要介绍（1）搭建UNIX世界框架的三个函数：fork()，wait()以及exec函数族；（2）守护进程；（3）系统日志">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/images/thumbnail/sp3-fork1.png">
<meta property="article:published_time" content="2023-08-22T12:00:00.000Z">
<meta property="article:modified_time" content="2023-08-22T08:45:41.325Z">
<meta property="article:author" content="flyingfox">
<meta property="article:tag" content="system programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/images/thumbnail/sp3-fork1.png">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 6.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                        
                                            <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                        
                                    
                                        
                                            <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                        
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">江城子同学</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>江城子同学</h2> <br />
                        <span>十年饮冰，难凉热血</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">第三章：进程</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2023-08-22T12:00:00.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2023-08-22</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">flyingfox</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~38.86K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1692693941325"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.</span> <span class="toc-text">进程标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">2.</span> <span class="toc-text">进程的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-2"><span class="toc-number">2.1.</span> <span class="toc-text">fork(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfork-2"><span class="toc-number">2.2.</span> <span class="toc-text">vfork(2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%B6%88%E4%BA%A1"><span class="toc-number">3.</span> <span class="toc-text">进程的消亡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-2"><span class="toc-number">3.1.</span> <span class="toc-text">wait(2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">4.</span> <span class="toc-text">exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execve-2"><span class="toc-number">4.1.</span> <span class="toc-text">execve(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-3"><span class="toc-number">4.2.</span> <span class="toc-text">exec(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90%EF%BC%9Ashell%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">举个栗子：shell的外部命令实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setsid-3POSIX"><span class="toc-number">5.1.</span> <span class="toc-text">setsid(3POSIX)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%8E%9F%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">编写原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-number">6.</span> <span class="toc-text">系统日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#openlog-3"><span class="toc-number">6.1.</span> <span class="toc-text">openlog(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#syslog-3"><span class="toc-number">6.2.</span> <span class="toc-text">syslog(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#closelog-3"><span class="toc-number">6.3.</span> <span class="toc-text">closelog(3)</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><p>主要介绍（1）搭建UNIX世界框架的三个函数：fork()，wait()以及exec函数族；（2）守护进程；（3）系统日志</p>
<span id="more"></span>

<p>注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数）</p>
<h2 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h2><p>pid_t：有符号的16位的整型数；现在pid_t在每一个不同机器上占多少位是不确定的。</p>
<p>常用ps指令组合：<code>ps axf</code>，<code>ps axm</code>，<code>ps ax -L</code>。</p>
<p>进程号是顺次向下使用，有别于文件描述符。</p>
<blockquote>
<p>  <em>GETPID(2)</em></p>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>getpid, getppid - get process identification</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;sys&#x2F;types.h&gt;</em></p>
<p>  ​       <em>#include &lt;unistd.h&gt;</em></p>
<p>  ​       <em>pid_t getpid(void);</em></p>
<p>  ​       <em>pid_t getppid(void);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>getpid() returns the process ID of the calling process.  (This is often used by routines that generate unique temporary filenames.)</em></p>
<p>  ​       <em>getppid() returns the process ID of the parent of the calling process.</em></p>
</blockquote>
<h2 id="进程的产生"><a href="#进程的产生" class="headerlink" title="进程的产生"></a>进程的产生</h2><p>注：<u>很多人学不好进程是什么，就是对fork()函数理解不够透彻</u>。</p>
<p>setjmp()函数执行一次，返回两次。fork()函数也是执行一次，返回两次，返回给两个不同的进程。</p>
<blockquote>
<p>  <em>为啥有些函数会执行一次，返回两次？如何实现的？</em></p>
</blockquote>
<h3 id="fork-2"><a href="#fork-2" class="headerlink" title="fork(2)"></a>fork(2)</h3><blockquote>
<p>  <em>FORK(2)</em></p>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>fork - create a child process</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;unistd.h&gt;</em></p>
<p>  ​       <em>pid_t fork(void);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>fork()  creates  a new process by</em> <em><strong>duplicating</strong></em> <em>the calling process.</em>  <em>The new process is referred to as the child process.  The calling process is referred to as the parent process.</em></p>
<p>  ​       <em><u>The child process and the parent process run in separate memory spaces.  At  the  time  of  fork() both  memory spaces have the same content</u>.  Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect the other.</em></p>
<p>  ​       <em>The child process is an exact duplicate of the parent process except for the following points:</em></p>
<p>  ​       <em>The child has its own unique process ID, and this PID does not match the  ID  of  any  existing process group (setpgid(2)).</em></p>
<p>  ​       <em>The child’s parent process ID is the same as the parent’s process ID.</em></p>
<p>  ​       <em>The child does not inherit its parent’s memory locks (mlock(2), mlockall(2)).</em></p>
<p>  ​       <em>Process resource utilizations (getrusage(2)) and CPU time counters (times(2)) are reset to zero in the child.</em></p>
<p>  ​       <em>The child’s set of pending signals is initially empty (sigpending(2)).</em></p>
<p>  ​       <em>The child does not inherit semaphore adjustments from its parent (semop(2)).</em></p>
<p>  ​       <em>The child does not inherit process-associated record locks from its parent (fcntl(2)).  (On the other  hand,  it  does inherit fcntl(2) open file description locks and flock(2) locks from its parent.)</em></p>
<p>  ​       <em>The child does not inherit timers from its parent (setitimer(2), alarm(2), timer_create(2)).</em></p>
<p>  ​       <em>The  child  does  not  inherit  outstanding  asynchronous  I&#x2F;O  operations  from   its   parent (aio_read(3),  aio_write(3)), nor does it inherit any asynchronous I&#x2F;O contexts from its parent (see io_setup(2)).</em></p>
<p>  ​       <em>The process attributes in the preceding list are all specified in POSIX.1.  The parent  and  child also differ with respect to the following Linux-specific process attributes:</em></p>
<p>  ​       <em>The  child  does  not inherit directory change notifications (dnotify) from its parent (see the description of F_NOTIFY in fcntl(2)).</em></p>
<p>  ​       <em>The prctl(2) PR_SET_PDEATHSIG setting is reset so that the child does not receive a signal when its parent terminates.</em></p>
<p>  ​       <em>The  default  timer  slack  value  is  set  to the parent’s current timer slack value.  See the description of PR_SET_TIMERSLACK in prctl(2).</em></p>
<p>  ​       <em>Memory mappings that have been marked with the madvise(2) MADV_DONTFORK flag are not  inherited across a fork().</em></p>
<p>  ​       <em>The termination signal of the child is always SIGCHLD (see clone(2)).</em></p>
<p>  ​       <em>The port access permission bits set by ioperm(2) are not inherited by the child; the child must turn on any bits that it requires using ioperm(2).</em></p>
<p>  ​       <em>Note the following further points:</em></p>
<p>  ​       <em>The child process is created with a single thread—the one that called fork().  The entire  virtual  address  space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of pthread_atfork(3)  may  be  helpful for dealing with problems that this can cause.</em></p>
<p>  ​       <em>After  a  fork(2)  in a multithreaded program, the child can safely call only async-signal-safe functions (see signal(7)) until such time as it calls execve(2).</em></p>
<p>  ​       <em>The child inherits copies of the parent’s set of open file descriptors.  Each  file  descriptor in  the  child refers to the same open file description (see open(2)) as the corresponding file descriptor in the parent.  This means that the two descriptors share open  file  status  flags, current  file  offset,  and  signal-driven  I&#x2F;O attributes (see the description of F_SETOWN and F_SETSIG in fcntl(2)).</em></p>
<p>  ​       <em>The child inherits copies of the parent’s set of open message queue descriptors  (see  mq_overview(7)).   Each  descriptor  in the child refers to the same open message queue description as the corresponding descriptor in the parent.  This means that the two descriptors share the same flags (mq_flags).</em></p>
<p>  ​       <em>The  child  inherits  copies  of  the  parent’s set of open directory streams (see opendir(3)). POSIX.1 says that the corresponding directory streams in the parent and  child  may  share  the directory stream positioning; on Linux&#x2F;glibc they do not.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em><strong>On  success,  the  PID  of  the  child process is returned in the parent, and 0 is returned in the child.  On failure, -1 is returned in the parent, no child process is created, and  errno  is  set appropriately.</strong></em></p>
<p>  <em><strong>ERRORS</strong></em></p>
<p>  ​       <em><strong>EAGAIN</strong></em>	<em>A  system-imposed  limit  on  the number of threads was encountered.  There are a number of limits that may trigger this error: the RLIMIT_NPROC soft resource  limit  (set  via  setrlimit(2)),  which  limits  the  number  of  processes  and  threads for a real user ID, was reached;  the  kernel’s  system-wide  limit  on  the  number  of  processes  and   threads, &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max,  was  reached  (see  proc(5)); or the maximum number of PIDs, &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max, was reached (see proc(5)).</em></p>
<p>  ​       <em><strong>EAGAIN</strong></em> 	<em>The caller is operating under the SCHED_DEADLINE scheduling policy and does  not  have  the reset-on-fork flag set.  See sched(7).</em></p>
<p>  ​       <em><strong>ENOMEM</strong></em> 	<em>fork() failed to allocate the necessary kernel structures because memory is tight.</em></p>
<p>  ​       <em><strong>ENOSYS</strong></em> 	<em>fork() is not supported on this platform (for example, hardware without a Memory-Management Unit).</em></p>
<p>  <em><strong>CONFORMING TO</strong></em></p>
<p>  ​       <em>POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.</em></p>
<p>  <em><strong>NOTES</strong></em></p>
<p>  ​       <em><u>Under Linux, fork() is implemented using copy-on-write pages, so the only penalty that  it  incurs is the time and memory required to duplicate the parent’s page tables, and to create a unique task structure for the child.</u></em></p>
<p>   <em><strong>C library&#x2F;kernel differences</strong></em></p>
<p>   ​       <em>Since version 2.3.3, rather than invoking the kernel’s fork() system call, the glibc fork()  wrapper that is provided as part of the NPTL threading implementation invokes clone(2) with flags that provide the same effect as the traditional system call.  (A call to fork() is equivalent to a call to  clone(2)  specifying flags as just SIGCHLD.)  The glibc wrapper invokes any fork handlers that have been established using pthread_atfork(3).</em></p>
<p>  <em><strong>EXAMPLE</strong></em></p>
<p>  ​       <em>See pipe(2) and wait(2).</em></p>
<p>  <em><strong>SEE ALSO</strong></em></p>
<p>  ​       <em>clone(2), execve(2), exit(2), setrlimit(2), unshare(2), vfork(2),  wait(2),  daemon(3),  capabilities(7), credentials(7)</em></p>
</blockquote>
<p>注意理解关键字：duplicating，意味着拷贝，克隆，一模一样等含义。</p>
<p>fork后父子进程的区别：<strong>fork的返回值不一样，pid不同，ppid也不同，未决信号和文件锁不继承，资源利用量归零</strong>。</p>
<p>未决信号：还没来得及响应的信号；</p>
<p>资源利用量归零：父进程如果使用了大量资源，怎么能带给子进程呢，否者磁盘限额就没意义了；</p>
<p>举个栗子：</p>
<p>写个程序来演示父子进程间的区别，能通过ps指令来显示父子进程的关系，并且展示缓冲机制在其中起的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>, getpid());</span><br><span class="line">	<span class="comment">// fflush(NULL);</span></span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working.\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working.\n&quot;</span>, getpid());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>, getpid());</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ make fork</span><br><span class="line">cc     fork.c   -o fork</span><br><span class="line">$ ./fork</span><br><span class="line">[33881]:Begin!</span><br><span class="line">[33881]:Parent is working.</span><br><span class="line">[33881]:End!</span><br><span class="line">[33882]:Child is working.</span><br><span class="line">[33882]:End!</span><br></pre></td></tr></table></figure>

<p>永远不要凭空猜测父子进程谁先被调度，因为哪个进程先运行是由调度器的调度策略来决定的。</p>
<p>如果将fork程序运行结果重定向至指定文件中，输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[33994]:Begin!</span><br><span class="line">[33994]:Parent is working.</span><br><span class="line">[33994]:End!</span><br><span class="line">[33994]:Begin!</span><br><span class="line">[33995]:Child is working.</span><br><span class="line">[33995]:End!</span><br></pre></td></tr></table></figure>

<p>“Begin!”字符串打印了两次。如果将<code>printf(&quot;[%d]:Begin!\n&quot;,getpid());</code>语句中的<code>\n</code>去掉，“Begin!”字符串依旧打印两次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork</span><br><span class="line">[34344]:Begin![34344]:Parent is working.</span><br><span class="line">[34344]:End!</span><br><span class="line">[34344]:Begin![34345]:Child is working.</span><br><span class="line">[34345]:End!</span><br></pre></td></tr></table></figure>

<p><strong>在调用fork()之前，要刷新所有成功打开的流</strong>。</p>
<p>全缓冲模式中，<code>\n</code>不表示刷新缓冲区，只表示换行。把Begin语句放到缓冲区中，还没来得及写到文件里去时，直接就fork()，父子进程的缓冲区里各自有一句Begin，那句Begin已经固定了，所以输出的是父进程的进程号。</p>
<p>调用fork()之前，先用fflush()刷新所有成功打开的流，重新编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ make fork</span><br><span class="line">cc     fork.c   -o fork</span><br><span class="line">$ ./fork</span><br><span class="line">[34459]:Begin!</span><br><span class="line">[34459]:Parent is working.</span><br><span class="line">[34459]:End!</span><br><span class="line">[34460]:Child is working.</span><br><span class="line">[34460]:End!</span><br><span class="line">$ ./fork &gt; /tmp/out</span><br><span class="line">$ <span class="built_in">cat</span> /tmp/out</span><br><span class="line">[34488]:Begin!</span><br><span class="line">[34488]:Parent is working.</span><br><span class="line">[34488]:End!</span><br><span class="line">[34489]:Child is working.</span><br><span class="line">[34489]:End!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  注：缓冲区机制会造成这样或那样的问题，为什么还要引入这样的机制呢？</p>
</blockquote>
<h3 id="vfork-2"><a href="#vfork-2" class="headerlink" title="vfork(2)"></a>vfork(2)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>vfork - create a child process and block parent</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;sys&#x2F;types.h&gt;</em></p>
<p>  ​       <em>#include &lt;unistd.h&gt;</em></p>
<p>  ​       <em>pid_t vfork(void);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>   <em><strong>Standard Description</strong></em></p>
<p>  ​       <em>(From POSIX.1) The vfork() function has the same effect as fork(2), except that  the behavior  is  undefined  if  the process created by vfork() either modifies any data other than a variable of type pid_t used to store the return value from vfork(),  or returns  from  the function in which vfork() was called, or calls any other function before successfully calling _exit(2) or one of the exec(3) family of functions.</em></p>
<p>   <em><strong>Linux Description</strong></em></p>
<p>  ​       <em>vfork(), just like fork(2), creates a child process of  the  calling  process.   For details and return value and errors, see fork(2).</em></p>
<p>  ​       <em>vfork()  is  a special case of clone(2).  It is used to create new processes without copying the page tables of the parent process.  It may be useful in performance-sensitive  applications  where  a  child  is  created  which then immediately issues an execve(2).</em></p>
<p>  ​       <em>vfork() differs from fork(2) in that the calling thread is suspended until the child terminates (either normally, by calling _exit(2), or abnormally, after delivery of a fatal signal), or it makes a call to execve(2).  Until that point, the child  shares all memory with its parent, including the stack.  The child must not return from the current function or call exit(3), but may call _exit(2).</em></p>
<p>  ​       <em>As with fork(2), the child process created by vfork() inherits copies of various  of the  caller’s  process  attributes (e.g., file descriptors, signal dispositions, and current working directory); the vfork() call differs only in the  treatment  of  the virtual address space, as described above.</em></p>
<p>  ​       <em>Signals  sent  to  the  parent  arrive  after the child releases the parent’s memory (i.e., after the child terminates or calls execve(2)).</em></p>
<p>   <em><strong>Historic Description</strong></em></p>
<p>  ​       <em>Under Linux, fork(2) is implemented using copy-on-write pages, so the  only  penalty incurred  by  fork(2) is the time and memory required to duplicate the parent’s page tables, and to create a unique task structure for the child.  However,  in  the  bad old  days a fork(2) would require making a complete copy of the caller’s data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced the vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent’s memory and thread of  control  until  a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.  The use of vfork()  was  tricky: for  example,  not  modifying  data  in the parent process depended on knowing which variables were held in a register.</em></p>
</blockquote>
<p><img src="https://flyingfox092-1300215590.cos.ap-shanghai.myqcloud.com/system-programming/sp3-fork1.png"></p>
<p>现在的fork()已经不是像上图那样了，而是添加了一个写时拷贝技术。在fork()时，父子进程共用同一个数据模块，如果父子进程对这些数据块是只读不写的，那谁也不会变，如果父子进程中有谁企图通过指针去写，那谁就自己memory copy一份，改自己的。</p>
<p><img src="https://flyingfox092-1300215590.cos.ap-shanghai.myqcloud.com/system-programming/sp3-fork2.png"></p>
<p>举个栗子：如果父子两个进程对于A都是只读，那谁也不干涉谁；如果有谁要改变A里面的数据，比如父进程，那么父进程memory copy一份到B，指针指向B了，改B里面的数据，A里面的数据不变。父子进程谁要改数据那就谁去拷贝。</p>
<p>fork()后来加了写时拷贝技术，相当于把vfork()融合进来了，甚至比它更灵活些，现在vfork()都快要废弃了。</p>
<p>面试题：在父进程中成功打开一个文件，捏着一个文件描述符fd，vfork()之后，在子进程中执行close(fd)，请问父进程中的fd有没有关闭？</p>
<blockquote>
<p>  (From POSIX.1) The vfork() function has the same effect as fork(2), except that  the behavior  is  undefined  if  the process created by vfork() either modifies any data other than a variable of type pid_t used to store the return value from vfork(),  or returns  from  the function in which vfork() was called, or calls any other function before successfully <strong>calling _exit(2) or one of the exec(3) family of functions</strong>.</p>
</blockquote>
<p>用vfork()产生的子进程只能做这两件事，所以父进程中的fd有没有关闭是不清楚的。</p>
<h2 id="进程的消亡"><a href="#进程的消亡" class="headerlink" title="进程的消亡"></a>进程的消亡</h2><h3 id="wait-2"><a href="#wait-2" class="headerlink" title="wait(2)"></a>wait(2)</h3><p>wait()收尸是死等，一直等到有进程的状态发生改变，会有信号通知wait()，然后wait()才去收尸。如果子进程出了问题，永远没办法回来或者不能通知wait()去给它收尸，那wait()就会一直等着。</p>
<blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>wait, waitpid -</em> <em><strong>wait for process to change state</strong></em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;sys&#x2F;types.h&gt;</em></p>
<p>  ​       <em>#include &lt;sys&#x2F;wait.h&gt;</em></p>
<p>  ​       <em>pid_t wait(int *status);</em></p>
<p>  ​       <em>pid_t waitpid(pid_t pid, int *status, int options);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em><u>All  of  these  system  calls  are  used  to wait for state changes in a child of the calling process, and obtain information about the child whose state has changed</u>.  A state  change  is considered  to  be: the child terminated; the child was stopped by a signal; or the child was resumed by a signal.  In the case of a terminated child, performing a wait allows the system to release the resources associated with the child; if a wait is not performed, then the terminated child remains in a “zombie” state (see NOTES below).</em></p>
<p>  ​       <em><u>If a child has already changed state, then these calls return immediately.   Otherwise,  they block  until  either  a child changes state or a signal handler interrupts the call (assuming that system calls are not automatically restarted using the SA_RESTART flag of sigaction(2)).</u> In  the  remainder  of  this page, a child whose state has changed and which has not yet been waited upon by one of these system calls is termed waitable.</em></p>
<p>   <em><strong>wait() and waitpid()</strong></em></p>
<p>  ​       <em>The wait() system call suspends execution of the calling process until one  of  its  children terminates.  The call wait(&amp;status) is equivalent to: waitpid(-1, &amp;status, 0);</em></p>
<p>  ​       <em>The  waitpid()  system call suspends execution of the calling process until a child specified by pid argument has changed state.  By default, waitpid() waits only for terminated children, but this behavior is modifiable via the options argument, as described below.</em></p>
<p>  ​       <em>The value of pid can be:</em></p>
<p>  ​       <em>&lt; -1   meaning  wait  for  any  child process whose process group ID is equal to the absolute value of pid.</em></p>
<p>  ​       <em>-1     meaning wait for any child process.</em></p>
<p>  ​       <em>0      meaning wait for any child process whose process group ID is  equal  to  that  of  the calling process.</em></p>
<p>  ​       <em>&gt; 0    meaning wait for the child whose process ID is equal to the value of pid.</em></p>
<p>  ​       <em>The value of options is an OR of zero or more of the following constants:</em></p>
<p>  ​       <em><strong>WNOHANG</strong>     return immediately if no child has exited.</em></p>
<p>  ​       <em><strong>WUNTRACED</strong>   also  return  if  a child has stopped (but not traced via ptrace(2)).  Status for traced children which have stopped is provided even if this option is not  specified.</em></p>
<p>  ​       <em><strong>WCONTINUED</strong> (since Linux 2.6.10) also return if a stopped child has been resumed by delivery of SIGCONT.</em></p>
<p>  ​       <em>(For Linux-only options, see below.)</em></p>
<p>  ​       <em>If  status  is not NULL, wait() and waitpid() store status information in the int to which it points.  This integer can be inspected with the following  macros  (which  take  the  integer itself as an argument, not a pointer to it, as is done in wait() and waitpid()!):</em></p>
<p>  ​     <em>WIFEXITED(status) returns  true  if  the  child  terminated  normally,  that  is,  by calling exit(3) or _exit(2), or by returning from main().</em></p>
<p>  ​       <em>WEXITSTATUS(status)  returns the exit status of the child.  This consists of the least significant  8  bits of the status argument that the child specified in a call to exit(3) or _exit(2) or as the argument for a return statement in main().  This macro should be employed only  if WIFEXITED returned true.</em></p>
<p>  ​       <em>WIFSIGNALED(status) returns true if the child process was terminated by a signal.</em></p>
<p>  ​       <em>WTERMSIG(status) returns  the  number  of  the signal that caused the child process to terminate.  This macro should be employed only if WIFSIGNALED returned true.</em></p>
<p>  ​       <em>WCOREDUMP(status) returns true if the child produced a core dump.  This macro should be employed only if WIFSIGNALED  returned  true.   This  macro is not specified in POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX, SunOS).  Only use this enclosed  in #ifdef WCOREDUMP … #endif.</em></p>
<p>  ​       <em>WIFSTOPPED(status) returns  true if the child process was stopped by delivery of a signal; this is possible only if the call was done using WUNTRACED or when the child is being  traced  (see ptrace(2)).</em></p>
<p>  ​       <em>WSTOPSIG(status) returns the number of the signal which caused the child to stop.  This macro should be employed only if WIFSTOPPED returned true.</em></p>
<p>  ​       <em>WIFCONTINUED(status) (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIGCONT.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>wait(): on success, returns the process ID of the terminated child; on error, -1 is returned.</em></p>
<p>  ​       <em>waitpid(): on success, returns the process ID of the child whose state has changed;  if  WNOHANG  was  specified  and  one  or  more  child(ren) specified by pid exist, but have not yet changed state, then 0 is returned.  On error, -1 is returned.</em></p>
<p>  ​       <em>Each of these calls sets errno to an appropriate value in the case of an error.</em></p>
</blockquote>
<p>waitpid()好用的地方不在于参数pid，而是参数options。options是个位图，最好用的一个是WNOHANG，</p>
<blockquote>
<p>  <em><strong>WNOHANG</strong>     return immediately if no child has exited.</em></p>
</blockquote>
<p>即使当前没有任何的child退出，如果加了WNOHANG选项的话，也会立马退出，相当于把waitpid()这个操作由阻塞变成了非阻塞。wait()是阻塞的，但是waitpid()加了WNOHANG选项后可以是非阻塞的。</p>
<p>wait()死等，收一个回来后才能看到是谁，waitpid()可以指定收谁，如果没添加WNOHANG选项，就相当于定向收尸的wait()，死等来收指定pid的子进程，如果添加WNOHANG选项，但子进程还在正常运行或者没达到收尸条件，马上走人，只有子进程结束了，那就收回来。收尸是等进程状态发生变化，才能取出退出码，释放资源，如果一个进程正常运行，收尸是收不回来的。</p>
<p>分组的目的就是统一操作，方便管理。</p>
<p>举个栗子：</p>
<p>写个程序来输出指定范围内的质数，将计算任务分配给子进程来完成，父进程负责收尸。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primer.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT	30000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT	30000200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, mark;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child process</span></span><br><span class="line">		&#123;</span><br><span class="line">			mark = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= i / <span class="number">2</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					mark = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mark)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// int st;</span></span><br><span class="line">	<span class="keyword">for</span> (i = LEFT; i &lt; RIGHT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// wait(&amp;st);</span></span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某次运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ ./primer </span><br><span class="line">30000023 is a primer.</span><br><span class="line">30000049 is a primer.</span><br><span class="line">30000037 is a primer.</span><br><span class="line">30000163 is a primer.</span><br><span class="line">30000133 is a primer.</span><br><span class="line">30000059 is a primer.</span><br><span class="line">30000071 is a primer.</span><br><span class="line">30000169 is a primer.</span><br><span class="line">30000041 is a primer.</span><br><span class="line">30000083 is a primer.</span><br><span class="line">30000193 is a primer.</span><br><span class="line">30000001 is a primer.</span><br><span class="line">30000079 is a primer.</span><br><span class="line">30000167 is a primer.</span><br><span class="line">30000199 is a primer.</span><br><span class="line">30000137 is a primer.</span><br><span class="line">30000109 is a primer.</span><br><span class="line">30000149 is a primer.</span><br></pre></td></tr></table></figure>

<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>“few”：fork，exec，wait。</p>
<p>父进程创建子进程的时候，是通过复制自己来实现的。</p>
<p>理解exec函数族的核心目的：它们用于在当前进程上下文中执行一个新程序。它们都会替换当前进程的映像，但保留进程ID、打开的文件描述符等。</p>
<p>区分函数：尝试将不同的exec函数与其特定功能关联起来：</p>
<ul>
<li>execl 和 execv：这两个函数允许你传递一个参数列表，其中execl使用可变参数列表，execv使用参数数组。</li>
<li>execle 和 execve：这两个函数除了接受参数列表外，还允许你传递环境变量数组。其中execle使用可变参数列表，execve使用参数数组。</li>
<li>execlp 和 execvp：这两个函数会在PATH环境变量中搜索可执行文件，而不需要提供可执行文件的完整路径。其中execlp使用可变参数列表，execvp使用参数数组。</li>
</ul>
<h3 id="execve-2"><a href="#execve-2" class="headerlink" title="execve(2)"></a>execve(2)</h3><blockquote>
<p>  <em>EXECVE(2)</em></p>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>execve - execute program</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;unistd.h&gt;</em></p>
<p>  ​       <em>int execve(const char *filename, char *const argv[], char *const envp[]);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>execve()  executes the program pointed to by filename.  filename must be either a binary executable, or a script starting with a line of the form:</em></p>
<p>  ​           <em>#! interpreter [optional-arg]</em></p>
<p>  ​       <em>For details of the latter case, see “Interpreter scripts” below.</em></p>
<p>  ​       <em>argv is an array of argument strings passed to the new program.  By convention, the first of these strings should contain  the  filename associated with the file being executed.  envp is an array of strings, conventionally of the form key&#x3D;value, which are passed as environment to the new program.  <strong>Both argv and envp must be terminated by a null pointer.</strong>  The argument vector and environment can be accessed by the called program’s main function, when it is defined as:</em></p>
<p>  ​           <em>int main(int argc, char *argv[], char *envp[])</em></p>
<p>  ​       <em><u>execve() does not return on success, and the text, data, bss, and stack of the calling process are overwritten by that of the program loaded.</u></em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>On success, execve() does not return, on error -1 is returned, and errno is set appropriately.</em></p>
<p>  <em><strong>Historical</strong></em></p>
<p>  ​       <em>With UNIX V6, the argument list of an exec() call was ended by 0, while the argument list of main was ended by -1.  Thus, this  argument list was not directly usable in a further exec() call.  Since UNIX V7, both are NULL.</em></p>
</blockquote>
<p>注：在《The C Programming Language》中，argv在索引中显示为参数向量，而非参数值。</p>
<p>argc：argument count</p>
<p>argv：argument vector</p>
<p>envp：environment pointer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myecho.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, j, argv[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execve.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *newargv[] = &#123; <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="type">char</span> *newenviron[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Usage: %s &lt;file-to-exec&gt;.\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newargv[<span class="number">0</span>] = argv[<span class="number">1</span>];</span><br><span class="line">    execve(argv[<span class="number">1</span>], newargv, newenviron);</span><br><span class="line">    perror(<span class="string">&quot;execve()&quot;</span>);     <span class="comment">// execve() returns only on error</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ make myecho</span><br><span class="line">cc     myecho.c   -o myecho</span><br><span class="line">$ make execve</span><br><span class="line">cc     execve.c   -o execve</span><br><span class="line">$ ./execve </span><br><span class="line">Usage: ./execve &lt;file-to-exec&gt;.</span><br><span class="line">$ ./execve myecho</span><br><span class="line">argv[0]: myecho</span><br><span class="line">argv[1]: hello</span><br><span class="line">argv[2]: world</span><br></pre></td></tr></table></figure>

<h3 id="exec-3"><a href="#exec-3" class="headerlink" title="exec(3)"></a>exec(3)</h3><blockquote>
<p>  <em>EXEC(3)</em></p>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>execl, execlp, execle, execv, execvp - execute a file</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;unistd.h&gt;</em></p>
<p>  ​       <em>extern char **environ;</em></p>
<p>  ​       <em>int execl(const char *path, const char *arg, … &#x2F;* (char  *) NULL *&#x2F;);</em></p>
<p>  ​       <em>int execlp(const char *file, const char *arg, … &#x2F;* (char  *) NULL *&#x2F;);</em></p>
<p>  ​       <em>int execle(const char *path, const char *arg, … &#x2F;*, (char *) NULL, char * const envp[] *&#x2F;);</em></p>
<p>  ​       <em>int execv(const char *path, char *const argv[]);</em></p>
<p>  ​       <em>int execvp(const char *file, char *const argv[]);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em><strong>The  exec()  family of functions replaces the current process image with a new process image</strong>.  The functions described in this manual page are front-ends for execve(2).  (See the manual page for execve(2) for further details about the replacement of the current process image.)</em></p>
<p>  ​       <em>The initial argument for these functions is the name of a file that is to be executed.</em></p>
<p>  ​       <em>The  const char *arg and subsequent ellipses in the execl(), execlp(), and execle() functions can be thought of as arg0, arg1, …, argn.  Together they describe a list of one or more pointers to null-terminated strings that represent the argument  list available to the executed program.  The first argument, by convention, should point to the filename associated with the file being executed.  The list of arguments must be terminated by a null pointer, and, since these  are variadic  functions,  this pointer must be cast (char *) NULL.</em></p>
<p>  ​       <em>The execv(), execvp(), and execvpe() functions provide an array of pointers to null-terminated strings that represent the argument list available to the new program.  The first argument, by convention, should point to the filename  associated  with the file being executed.  The array of pointers must be terminated by a null pointer.</em></p>
<p>  ​       <em>The  execle()  and  execvpe()  functions  allow the caller to specify the environment of the executed program via the argument envp.  The envp argument is an array of pointers to null-terminated strings and must be terminated by  a  null  pointer.   The other functions take the environment for the new process image from the external variable environ in the calling process.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>The exec() functions return only if an error has occurred.  The return value is -1, and errno is set to indicate the error.</em></p>
<p>  <em><strong>ERRORS</strong></em></p>
<p>  ​       <em>All of these functions may fail and set errno for any of the errors specified for execve(2).</em></p>
<p>  <em><strong>NOTES</strong></em></p>
<p>  ​       <em>On some other systems, the default path (used when the environment does not contain the variable PATH) has the current working directory listed after &#x2F;bin and &#x2F;usr&#x2F;bin, as an anti-Trojan-horse measure.  Linux uses here the traditional “current directory first” default path.</em></p>
<p>  ​       <em>The behavior of execlp() and execvp() when errors occur while attempting to execute the file is historic practice, but has not traditionally  been  documented  and is not specified by the POSIX standard.  BSD (and possibly other systems) do an automatic sleep and retry if ETXTBSY is encountered.  Linux treats it as a hard error and returns immediately.</em></p>
<p>  ​       <em>Traditionally, the functions execlp() and execvp() ignored all errors except for the  ones  described  above  and  ENOMEM  and E2BIG, upon which they returned.  They now return if any error other than the ones described above occurs.</em></p>
</blockquote>
<p><img src="https://flyingfox092-1300215590.cos.ap-shanghai.myqcloud.com/system-programming/sp3-execX-function.png"></p>
<p>注：5个exec族函数中，哪些是定长参数，哪些是可变长参数？</p>
<p>进程空间搭建的过程中，在exec阶段就已经有了代码段，已初始化数据段，未初始化数据段等，堆和栈是在后来才搭建起来的。</p>
<p>注：<strong>在调用execl()函数之前要刷新所有该刷新的数据流</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execl.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Begin!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	execl(<span class="string">&quot;/bin/date&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execl()的第二个参数传参一定要从argv[0]开始。</p>
<p>UNIX世界就是由这三个函数搭建起来的：fork()，exec()，wait()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// few.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Begin!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">&quot;/bin/date&quot;</span>,<span class="string">&quot;date&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make few</span><br><span class="line">cc     few.c   -o few</span><br><span class="line">$ ./few</span><br><span class="line">Begin!</span><br><span class="line">2023年 01月 13日 星期五 14:11:05 CST</span><br><span class="line">End!</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sleep.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Begin!\n&quot;</span>);</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">&quot;/bin/sleep&quot;</span>,<span class="string">&quot;httpd&quot;</span>,<span class="string">&quot;100&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://flyingfox092-1300215590.cos.ap-shanghai.myqcloud.com/system-programming/sp3-sleep-result.png"></p>
<p>注：argv[0]处的”httpd”类似于一个别名，会显示在进程关系中。这样可以实现木马的一种低级藏身办法，高级一点的可以隐藏在内核模块中，但是这样危害就不如在用户态大了（为啥呀？？？）。</p>
<h3 id="举个栗子：shell的外部命令实现"><a href="#举个栗子：shell的外部命令实现" class="headerlink" title="举个栗子：shell的外部命令实现"></a>举个栗子：shell的外部命令实现</h3><p>shell的外部命令处理思路【伪代码】：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prompt();</span><br><span class="line"></span><br><span class="line">        getline();</span><br><span class="line"></span><br><span class="line">        parse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(内部命令)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 外部命令</span></span><br><span class="line">            fork();</span><br><span class="line">            <span class="keyword">if</span>( &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror();</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( == <span class="number">0</span>)   <span class="comment">// child process</span></span><br><span class="line">            &#123;</span><br><span class="line">                execX();</span><br><span class="line">                perror();</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;      <span class="comment">// parent</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysh.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELIMS      <span class="string">&quot; \t\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">glob_t</span> globres;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prompt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mysh-0.1$ &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse</span><span class="params">(<span class="type">char</span> *line,<span class="keyword">struct</span> cmd_st *res)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *tok;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tok = strsep(&amp;line,DELIMS);</span><br><span class="line">        <span class="keyword">if</span>(tok == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(tok[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        glob(tok,GLOB_NOCHECK|GLOB_APPEND*i,<span class="literal">NULL</span>,&amp;res-&gt;globres);</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> linebuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span> <span class="title">cmd</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prompt();</span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf,&amp;linebuf_size,<span class="built_in">stdin</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        parse(linebuf,&amp;cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>)   <span class="comment">// 内部命令</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* do something */</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 外部命令</span></span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)   <span class="comment">// child process</span></span><br><span class="line">            &#123;</span><br><span class="line">                execvp(cmd.globres.gl_pathv[<span class="number">0</span>],cmd.globres.gl_pathv);</span><br><span class="line">                perror(<span class="string">&quot;execvp()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;        <span class="comment">// parent</span></span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <em><strong>GLOB_NOCHECK</strong>	If  no  pattern  matches,  return the original pattern.  By default, glob() returns <strong>GLOB_NOMATCH</strong> if there are no matches.</em></p>
</blockquote>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>在UNIX系统编程中，经常需要创建守护进程。守护进程一般脱离控制终端，是后台运行的进程，与终端无关。为了使进程完全脱离其父进程和终端，我们需要使用 setsid() 函数来创建新的会话。</p>
<p>注：守护进程一般脱离控制终端，是一个会话的leader，进程组的leader。</p>
<h3 id="setsid-3POSIX"><a href="#setsid-3POSIX" class="headerlink" title="setsid(3POSIX)"></a>setsid(3POSIX)</h3><blockquote>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>setsid — create session and set process group ID</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;unistd.h&gt;</em></p>
<p>  ​       <em>pid_t setsid(void);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>  ​       <em>The setsid() function shall create a new session, if the calling process is not a process group leader. Upon return the calling process shall be the session leader  of  this  new  session, shall  be  the  process group leader of a new process group, and shall have no controlling terminal. The process group ID of the calling process shall be set equal to the process ID of the calling process. The calling process shall be the only process in the new process group and the only process in the new session.</em></p>
<p>  <em><strong>RETURN VALUE</strong></em></p>
<p>  ​       <em>Upon successful completion, setsid() shall return the value of the new process group ID of the calling process. Otherwise, it shall return −1 and set errno to indicate the error.</em></p>
<p>  <em><strong>ERRORS</strong></em></p>
<p>  ​       <em>The setsid() function shall fail if:</em></p>
<p>  ​       <em><strong>EPERM</strong>  The calling process is already a process group leader, or the process group ID of a process other than the calling process matches the process ID of the calling process.</em></p>
</blockquote>
<p>setsid() 函数用于创建新的会话，并做以下三件事情：</p>
<ol>
<li>使调用进程成为新会话的领头进程。</li>
<li>使调用进程成为新进程组的领头进程。</li>
<li>使调用进程没有控制终端。</li>
</ol>
<p>注意事项：</p>
<ol>
<li>如果调用进程已经是进程组的领头进程，则 setsid() 调用将失败。</li>
<li>为了确保调用进程不是进程组的领头进程，通常首先进行 fork() 操作，然后在子进程中调用 setsid()。这样，父进程可以正常退出，而子进程保证不是进程组的领头进程。</li>
<li>setsid() 使得进程脱离原有的终端、会话和进程组，并建立一个新会话，此时该进程是新会话的领头进程和新进程组的领头进程。</li>
</ol>
<h3 id="编写原则"><a href="#编写原则" class="headerlink" title="编写原则"></a>编写原则</h3><ol>
<li><strong>创建孤儿进程</strong>：创建（fork）一个子进程并使父进程退出（exit），使子进程成为孤儿进程。子进程虽然继承了父进程的进程组ID，但获得了一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这是后面调用 setsid() 的先决条件。</li>
<li><strong>创建新的会话</strong>：调用 setsid() 创建一个新的会话，使调用进程成为新会话的首进程，一个新进程组的组长进程，没有控制终端。</li>
<li><strong>更改工作目录</strong>：将守护进程的工作目录更改为根目录（”&#x2F;“），以确保守护进程不会占用其他文件系统的资源。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。</li>
<li><strong>重设 umask</strong>：将 umask 设置为 0，以便守护进程创建的任何文件或目录具有合适的权限。这样可以避免权限问题。</li>
<li><strong>关闭文件描述符</strong>：关闭从父进程继承的所有打开的文件描述符。通常，需要循环遍历所有可能的文件描述符，从 0 开始，一直到系统定义的最大文件描述符。</li>
<li><strong>重定向标准文件描述符</strong>：使用 open() 系统调用打开 &#x2F;dev&#x2F;null。然后使用 dup2() 系统调用将标准输入、标准输出和标准错误重定向到刚打开的 &#x2F;dev&#x2F;null。这样可以避免输出混乱和不必要的资源占用。</li>
<li><strong>设置信号处理</strong>：使用 sigaction() 或 signal() 函数设置适当的信号处理程序，以便守护进程能够优雅地处理系统发送的信号。例如，确保在收到 SIGTERM 信号时守护进程可以正常终止。</li>
<li><strong>启动核心服务</strong>：编写守护进程的核心功能，处理任务并在需要时与其他系统组件交互。这可能包括监听套接字、执行周期性任务或监视文件系统更改。</li>
<li><strong>使用锁文件或 PID 文件</strong>：使用 open() 和 write() 系统调用创建一个锁文件或 PID 文件，将守护进程的进程 ID 写入其中。这有助于避免同一守护进程的多个实例同时运行，并允许其他进程监视或管理守护进程。</li>
<li><strong>使用系统日志</strong>：使用 syslog() 函数将重要信息、错误或警告记录到系统日志，以便管理员能够监视守护进程的状态和活动。这通常包括配置日志优先级、打开日志连接并在创建守护进程时，确保将关键信息、错误或警告记录到系统日志中非常重要。</li>
</ol>
<p>注：</p>
<p>（1）PID，PGID，SID三者一致，父进程为1号进程，且脱离终端，可知某进程是否为守护进程</p>
<p>（2）ps axj显示结果中的TTY栏，”?”表示脱离控制终端。</p>
<p>举个栗子：</p>
<p>以守护进程的方式，每隔1秒，向指定文件中写入指定格式的当前系统时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mydaemon.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FILE <span class="string">&quot;/var/log/mydaemon.log&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    setsid();</span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open log file and redirect stdin,stdout,stderr to it</span></span><br><span class="line">    fd = open(LOG_FILE, O_CREAT | O_WRONLY | O_APPEND, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd, STDIN_FILENO);</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Get current time</span></span><br><span class="line">        <span class="type">time_t</span> current_time = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">local_time</span> =</span> localtime(&amp;current_time);</span><br><span class="line">        <span class="type">char</span> timestamp[<span class="number">20</span>];</span><br><span class="line">        strftime(timestamp, <span class="keyword">sizeof</span>(timestamp), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, local_time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open log file and write timestamp</span></span><br><span class="line">        FILE *fp = fopen(LOG_FILE, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s\n&quot;</span>, timestamp);</span><br><span class="line">            fclose(fp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：运行时需要root权限，杀死该进程：<code>sudo killall mydaemon</code>。</p>
<p>通过 <code>ps axj</code> 指令查看mydaemon进程为守护进程，通过 <code>sudo tail -f /var/log/mydaemon.log</code> 动态查看文件内容。</p>
<h2 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h2><p>每个应用程序都有必要写系统日志，但不是每一个程序都有权限去写，所以都把内容提交给syslogd服务，由它统一去写。权限分割。</p>
<blockquote>
<p>  <em>SYSLOG(3)</em></p>
<p>  <em><strong>NAME</strong></em></p>
<p>  ​       <em>closelog, openlog, syslog - send messages to the system logger</em></p>
<p>  <em><strong>SYNOPSIS</strong></em></p>
<p>  ​       <em>#include &lt;syslog.h&gt;</em></p>
<p>  ​       <em>void openlog(const char *ident, int option, int facility);</em></p>
<p>  ​       <em>void syslog(int priority, const char *format, …);</em></p>
<p>  ​       <em>void closelog(void);</em></p>
<p>  <em><strong>DESCRIPTION</strong></em></p>
<p>   <em><strong>openlog()</strong></em></p>
<p>  ​       <em>openlog() opens a connection to the system logger for a program.</em></p>
<p>  ​       <em>The  string pointed to by ident is prepended to every message, and is typically set to the program name.  If ident is NULL, the program name is used. (POSIX.1-2008 does not specify the behavior when ident is NULL.)</em></p>
<p>  ​       <em>The  option  argument  specifies flags which control the operation of openlog() and subsequent calls to syslog().  The facility argument  establishes a  default to be used if none is specified in subsequent calls to syslog(). The values that may be specified for option and facility are described  below.</em></p>
<p>  ​       <em>The  use  of openlog() is optional; it will automatically be called by syslog() if necessary, in which case ident will default to NULL.</em></p>
<p>   <em><strong>syslog()</strong></em></p>
<p>  ​       <em>syslog() generates a log message, which will be distributed by syslogd(8).</em></p>
<p>  ​       <em>The priority argument is formed by ORing together a facility  value  and  a level value (described below).  If no facility value is ORed into priority, then the default value set by openlog() is used, or, if there was  no  preceding openlog() call, a default of LOG_USER is employed.</em></p>
<p>  ​       <em>The  remaining  arguments  are a format, as in printf(3), and any arguments required by the format, except that the two-character sequence %m  will  be replaced  by  the  error message string strerror(errno).  The format string need not include a terminating newline character.</em></p>
<p>   <em><strong>closelog()</strong></em></p>
<p>  ​       <em>closelog() closes the file descriptor being used to  write  to  the  system logger.  The use of closelog() is optional.</em></p>
</blockquote>
<h3 id="openlog-3"><a href="#openlog-3" class="headerlink" title="openlog(3)"></a>openlog(3)</h3><p>openlog() 函数用于打开与系统日志守护进程的连接。它允许设置日志选项、指定消息来源标识符和定义消息设施。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>ident</code>：一个字符串，用作消息来源的标识符。此字符串将添加到每条日志消息的开头。</li>
<li><code>option</code>：一个位掩码，用于设置日志选项。例如，LOG_CONS（如果消息无法发送到系统日志，则将其写入控制台）、LOG_PID（在每条消息中包含调用进程的进程 ID）、LOG_NDELAY（立即打开与系统日志的连接，而不是在写入第一条消息时）等。</li>
<li><code>facility</code>：一个整数，表示消息的来源类型。例如，LOG_USER（用户级消息）、LOG_LOCAL0（本地使用的设施 0）、LOG_DAEMON（系统守护进程）等。</li>
</ul>
<p>示例：openlog(“my_daemon”, LOG_PID | LOG_CONS, LOG_DAEMON);</p>
<h3 id="syslog-3"><a href="#syslog-3" class="headerlink" title="syslog(3)"></a>syslog(3)</h3><p>syslog() 函数用于向系统日志写入日志消息。它接受一个整数优先级和一个格式化字符串作为参数，以及与格式化字符串中的格式说明符对应的可变参数列表。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>priority</code>：消息的优先级，由一个或多个日志级别（例如，LOG_ERR、LOG_WARNING）和一个日志设施（例如，LOG_USER、LOG_DAEMON）组成。日志级别和日志设施可以使用按位或运算符（|）组合。</li>
<li><code>format</code>：一个格式化字符串，类似于 printf() 函数使用的字符串。它可以包含格式说明符（例如，%s、%d），以及用于描述消息内容的文本。</li>
<li><code>...</code>：可变参数列表，与格式字符串中的格式说明符相对应。</li>
</ul>
<p>示例：syslog(LOG_ERR | LOG_USER, “An error occurred: %s”, error_message);</p>
<h3 id="closelog-3"><a href="#closelog-3" class="headerlink" title="closelog(3)"></a>closelog(3)</h3><p>closelog() 函数用于关闭与系统日志守护进程的连接。在程序结束时调用此函数是一种良好的做法，尽管在程序退出时，资源会自动释放。</p>
<p>举个栗子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syslog.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开与系统日志的连接，并设置日志选项和设施</span></span><br><span class="line">    openlog(<span class="string">&quot;my_app&quot;</span>, LOG_PID | LOG_CONS, LOG_USER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录一条信息级别的日志消息</span></span><br><span class="line">    syslog(LOG_INFO, <span class="string">&quot;Application started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟程序执行过程中发生的错误</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">1</span>) &#123;</span><br><span class="line">        syslog(LOG_ERR, <span class="string">&quot;An error occurred: result is not equal to 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录一条通知级别的日志消息</span></span><br><span class="line">    syslog(LOG_NOTICE, <span class="string">&quot;Application is about to exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭与系统日志的连接</span></span><br><span class="line">    closelog();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行此示例程序后，可以在系统日志中找到相应的日志记录。在许多 Linux 发行版中，这些记录可以在 <code>/var/log/syslog</code> 或 <code>/var/log/messages</code> 文件中找到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel@Ubuntu22:/var/log$ <span class="built_in">tail</span> syslog</span><br><span class="line">......</span><br><span class="line">Apr  5 20:30:13 Ubuntu22 my_app[10702]: Application started</span><br><span class="line">Apr  5 20:30:13 Ubuntu22 my_app[10702]: An error occurred: result is not equal to 1</span><br><span class="line">Apr  5 20:30:13 Ubuntu22 my_app[10702]: Application is about to <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/";
            const title         = "「第三章：进程」";
            const excerpt       = `主要介绍（1）搭建UNIX世界框架的三个函数：fork()，wait()以及exec函数族；（2）守护进程；（3）系统日志`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/system-programming/" rel="tag">system programming</a>
                </div>
                <div class="pull-date">
                    <time datetime="2023-08-22T08:45:41.325Z" itemprop="dateModified">最后编辑：2023-08-22</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 钩子函数|进程的终止方式" href="/2023/08/18/钩子函数/">&lt; 上一篇</a>
            </div>
            
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.png" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                15
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                5
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                7
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">进程标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-text">进程的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-2"><span class="toc-text">fork(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfork-2"><span class="toc-text">vfork(2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%B6%88%E4%BA%A1"><span class="toc-text">进程的消亡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-2"><span class="toc-text">wait(2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-text">exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execve-2"><span class="toc-text">execve(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-3"><span class="toc-text">exec(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90%EF%BC%9Ashell%E7%9A%84%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-text">举个栗子：shell的外部命令实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setsid-3POSIX"><span class="toc-text">setsid(3POSIX)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%8E%9F%E5%88%99"><span class="toc-text">编写原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-text">系统日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#openlog-3"><span class="toc-text">openlog(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#syslog-3"><span class="toc-text">syslog(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#closelog-3"><span class="toc-text">closelog(3)</span></a></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SQL%E6%B3%A8%E5%85%A5/">SQL注入</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/">《系统编程实践（C语言版）》</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E6%BF%80%E6%B4%BB/">软件激活</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/BurpSuite/" style="font-size: 0.6em;">BurpSuite</a> <a href="/tags/DynELF/" style="font-size: 0.6em;">DynELF</a> <a href="/tags/ELF/" style="font-size: 0.6em;">ELF</a> <a href="/tags/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/" style="font-size: 0.6em;">SSH免密登录</a> <a href="/tags/system-programming/" style="font-size: 0.8em;">system programming</a> <a href="/tags/%E5%85%B1%E4%BA%AB%E5%BA%93/" style="font-size: 0.6em;">共享库</a> <a href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" style="font-size: 0.6em;">动态链接</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/"><i class="fa  fa-book"></i> 第三章：进程</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/18/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"><i class="fa  fa-book"></i> 钩子函数|进程的终止方式</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/17/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90/"><i class="fa  fa-book"></i> 解析命令行参数</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/"><i class="fa  fa-book"></i> 第五章：线程相关函数</a>
            
          
        
          
          
            <a class="list-group-item" href="/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"><i class="fa  fa-book"></i> 第五章：线程同步机制</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 江城子同学 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by flyingfox.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                    <div class="box theme-box" id="snow-switch">
                        <span class="fa fa-snowflake-o"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>

    <div>
        <canvas id="snow"></canvas>
        <script async src="/js/snow.min.js"></script>
    </div>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>