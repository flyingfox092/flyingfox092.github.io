[{"title":"第三章：进程","date":"2023-08-22T12:00:00.000Z","url":"/2023/08/22/Chapter3_%E8%BF%9B%E7%A8%8B/","tags":[["system programming","/tags/system-programming/"]],"categories":[["《系统编程实践（C语言版）》","/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/"]],"content":"主要介绍（1）搭建UNIX世界框架的三个函数：fork()，wait()以及exec函数族；（2）守护进程；（3）系统日志 注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数） 进程标识符pid_t：有符号的16位的整型数；现在pid_t在每一个不同机器上占多少位是不确定的。 常用ps指令组合：ps axf，ps axm，ps ax -L。 进程号是顺次向下使用，有别于文件描述符。 GETPID(2) NAME ​ getpid, getppid - get process identification SYNOPSIS ​ #include &lt;sys&#x2F;types.h&gt; ​ #include &lt;unistd.h&gt; ​ pid_t getpid(void); ​ pid_t getppid(void); DESCRIPTION ​ getpid() returns the process ID of the calling process. (This is often used by routines that generate unique temporary filenames.) ​ getppid() returns the process ID of the parent of the calling process. 进程的产生注：很多人学不好进程是什么，就是对fork()函数理解不够透彻。 setjmp()函数执行一次，返回两次。fork()函数也是执行一次，返回两次，返回给两个不同的进程。 为啥有些函数会执行一次，返回两次？如何实现的？ fork(2) FORK(2) NAME ​ fork - create a child process SYNOPSIS ​ #include &lt;unistd.h&gt; ​ pid_t fork(void); DESCRIPTION ​ fork() creates a new process by duplicating the calling process. The new process is referred to as the child process. The calling process is referred to as the parent process. ​ The child process and the parent process run in separate memory spaces. At the time of fork() both memory spaces have the same content. Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by one of the processes do not affect the other. ​ The child process is an exact duplicate of the parent process except for the following points: ​ ** The child has its own unique process ID, and this PID does not match the ID of any existing process group (setpgid(2)).* ​ ** The child’s parent process ID is the same as the parent’s process ID.* ​ ** The child does not inherit its parent’s memory locks (mlock(2), mlockall(2)).* ​ ** Process resource utilizations (getrusage(2)) and CPU time counters (times(2)) are reset to zero in the child.* ​ ** The child’s set of pending signals is initially empty (sigpending(2)).* ​ ** The child does not inherit semaphore adjustments from its parent (semop(2)).* ​ ** The child does not inherit process-associated record locks from its parent (fcntl(2)). (On the other hand, it does inherit fcntl(2) open file description locks and flock(2) locks from its parent.)* ​ ** The child does not inherit timers from its parent (setitimer(2), alarm(2), timer_create(2)).* ​ ** The child does not inherit outstanding asynchronous I&#x2F;O operations from its parent (aio_read(3), aio_write(3)), nor does it inherit any asynchronous I&#x2F;O contexts from its parent (see io_setup(2)).* ​ The process attributes in the preceding list are all specified in POSIX.1. The parent and child also differ with respect to the following Linux-specific process attributes: ​ ** The child does not inherit directory change notifications (dnotify) from its parent (see the description of F_NOTIFY in fcntl(2)).* ​ ** The prctl(2) PR_SET_PDEATHSIG setting is reset so that the child does not receive a signal when its parent terminates.* ​ ** The default timer slack value is set to the parent’s current timer slack value. See the description of PR_SET_TIMERSLACK in prctl(2).* ​ ** Memory mappings that have been marked with the madvise(2) MADV_DONTFORK flag are not inherited across a fork().* ​ ** The termination signal of the child is always SIGCHLD (see clone(2)).* ​ ** The port access permission bits set by ioperm(2) are not inherited by the child; the child must turn on any bits that it requires using ioperm(2).* ​ Note the following further points: ​ ** The child process is created with a single thread—the one that called fork(). The entire virtual address space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of pthread_atfork(3) may be helpful for dealing with problems that this can cause.* ​ ** After a fork(2) in a multithreaded program, the child can safely call only async-signal-safe functions (see signal(7)) until such time as it calls execve(2).* ​ ** The child inherits copies of the parent’s set of open file descriptors. Each file descriptor in the child refers to the same open file description (see open(2)) as the corresponding file descriptor in the parent. This means that the two descriptors share open file status flags, current file offset, and signal-driven I&#x2F;O attributes (see the description of F_SETOWN and F_SETSIG in fcntl(2)).* ​ ** The child inherits copies of the parent’s set of open message queue descriptors (see mq_overview(7)). Each descriptor in the child refers to the same open message queue description as the corresponding descriptor in the parent. This means that the two descriptors share the same flags (mq_flags).* ​ ** The child inherits copies of the parent’s set of open directory streams (see opendir(3)). POSIX.1 says that the corresponding directory streams in the parent and child may share the directory stream positioning; on Linux&#x2F;glibc they do not.* RETURN VALUE ​ On success, the PID of the child process is returned in the parent, and 0 is returned in the child. On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately. ERRORS ​ EAGAIN A system-imposed limit on the number of threads was encountered. There are a number of limits that may trigger this error: the RLIMIT_NPROC soft resource limit (set via setrlimit(2)), which limits the number of processes and threads for a real user ID, was reached; the kernel’s system-wide limit on the number of processes and threads, &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max, was reached (see proc(5)); or the maximum number of PIDs, &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max, was reached (see proc(5)). ​ EAGAIN The caller is operating under the SCHED_DEADLINE scheduling policy and does not have the reset-on-fork flag set. See sched(7). ​ ENOMEM fork() failed to allocate the necessary kernel structures because memory is tight. ​ ENOSYS fork() is not supported on this platform (for example, hardware without a Memory-Management Unit). CONFORMING TO ​ POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD. NOTES ​ Under Linux, fork() is implemented using copy-on-write pages, so the only penalty that it incurs is the time and memory required to duplicate the parent’s page tables, and to create a unique task structure for the child. ​ Since version 2.3.3, rather than invoking the kernel’s fork() system call, the glibc fork() wrapper that is provided as part of the NPTL threading implementation invokes clone(2) with flags that provide the same effect as the traditional system call. (A call to fork() is equivalent to a call to clone(2) specifying flags as just SIGCHLD.) The glibc wrapper invokes any fork handlers that have been established using pthread_atfork(3). EXAMPLE ​ See pipe(2) and wait(2). SEE ALSO ​ clone(2), execve(2), exit(2), setrlimit(2), unshare(2), vfork(2), wait(2), daemon(3), capabilities(7), credentials(7) 注意理解关键字：duplicating，意味着拷贝，克隆，一模一样等含义。 fork后父子进程的区别：fork的返回值不一样，pid不同，ppid也不同，未决信号和文件锁不继承，资源利用量归零。 未决信号：还没来得及响应的信号； 资源利用量归零：父进程如果使用了大量资源，怎么能带给子进程呢，否者磁盘限额就没意义了； 举个栗子： 写个程序来演示父子进程间的区别，能通过ps指令来显示父子进程的关系，并且展示缓冲机制在其中起的作用。 编译运行结果如下： 永远不要凭空猜测父子进程谁先被调度，因为哪个进程先运行是由调度器的调度策略来决定的。 如果将fork程序运行结果重定向至指定文件中，输出结果如下： “Begin!”字符串打印了两次。如果将printf(&quot;[%d]:Begin!\\n&quot;,getpid());语句中的\\n去掉，“Begin!”字符串依旧打印两次。 在调用fork()之前，要刷新所有成功打开的流。 全缓冲模式中，\\n不表示刷新缓冲区，只表示换行。把Begin语句放到缓冲区中，还没来得及写到文件里去时，直接就fork()，父子进程的缓冲区里各自有一句Begin，那句Begin已经固定了，所以输出的是父进程的进程号。 调用fork()之前，先用fflush()刷新所有成功打开的流，重新编译运行结果如下： 注：缓冲区机制会造成这样或那样的问题，为什么还要引入这样的机制呢？ vfork(2) NAME ​ vfork - create a child process and block parent SYNOPSIS ​ #include &lt;sys&#x2F;types.h&gt; ​ #include &lt;unistd.h&gt; ​ pid_t vfork(void); DESCRIPTION ​ (From POSIX.1) The vfork() function has the same effect as fork(2), except that the behavior is undefined if the process created by vfork() either modifies any data other than a variable of type pid_t used to store the return value from vfork(), or returns from the function in which vfork() was called, or calls any other function before successfully calling _exit(2) or one of the exec(3) family of functions. ​ vfork(), just like fork(2), creates a child process of the calling process. For details and return value and errors, see fork(2). ​ vfork() is a special case of clone(2). It is used to create new processes without copying the page tables of the parent process. It may be useful in performance-sensitive applications where a child is created which then immediately issues an execve(2). ​ vfork() differs from fork(2) in that the calling thread is suspended until the child terminates (either normally, by calling _exit(2), or abnormally, after delivery of a fatal signal), or it makes a call to execve(2). Until that point, the child shares all memory with its parent, including the stack. The child must not return from the current function or call exit(3), but may call _exit(2). ​ As with fork(2), the child process created by vfork() inherits copies of various of the caller’s process attributes (e.g., file descriptors, signal dispositions, and current working directory); the vfork() call differs only in the treatment of the virtual address space, as described above. ​ Signals sent to the parent arrive after the child releases the parent’s memory (i.e., after the child terminates or calls execve(2)). ​ Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the parent’s page tables, and to create a unique task structure for the child. However, in the bad old days a fork(2) would require making a complete copy of the caller’s data space, often needlessly, since usually immediately afterward an exec(3) is done. Thus, for greater efficiency, BSD introduced the vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent’s memory and thread of control until a call to execve(2) or an exit occurred. The parent process was suspended while the child was using its resources. The use of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register. 现在的fork()已经不是像上图那样了，而是添加了一个写时拷贝技术。在fork()时，父子进程共用同一个数据模块，如果父子进程对这些数据块是只读不写的，那谁也不会变，如果父子进程中有谁企图通过指针去写，那谁就自己memory copy一份，改自己的。 举个栗子：如果父子两个进程对于A都是只读，那谁也不干涉谁；如果有谁要改变A里面的数据，比如父进程，那么父进程memory copy一份到B，指针指向B了，改B里面的数据，A里面的数据不变。父子进程谁要改数据那就谁去拷贝。 fork()后来加了写时拷贝技术，相当于把vfork()融合进来了，甚至比它更灵活些，现在vfork()都快要废弃了。 面试题：在父进程中成功打开一个文件，捏着一个文件描述符fd，vfork()之后，在子进程中执行close(fd)，请问父进程中的fd有没有关闭？ (From POSIX.1) The vfork() function has the same effect as fork(2), except that the behavior is undefined if the process created by vfork() either modifies any data other than a variable of type pid_t used to store the return value from vfork(), or returns from the function in which vfork() was called, or calls any other function before successfully calling _exit(2) or one of the exec(3) family of functions. 用vfork()产生的子进程只能做这两件事，所以父进程中的fd有没有关闭是不清楚的。 进程的消亡wait(2)wait()收尸是死等，一直等到有进程的状态发生改变，会有信号通知wait()，然后wait()才去收尸。如果子进程出了问题，永远没办法回来或者不能通知wait()去给它收尸，那wait()就会一直等着。 NAME ​ wait, waitpid - wait for process to change state SYNOPSIS ​ #include &lt;sys&#x2F;types.h&gt; ​ #include &lt;sys&#x2F;wait.h&gt; ​ pid_t wait(int *status); ​ pid_t waitpid(pid_t pid, int *status, int options); DESCRIPTION ​ All of these system calls are used to wait for state changes in a child of the calling process, and obtain information about the child whose state has changed. A state change is considered to be: the child terminated; the child was stopped by a signal; or the child was resumed by a signal. In the case of a terminated child, performing a wait allows the system to release the resources associated with the child; if a wait is not performed, then the terminated child remains in a “zombie” state (see NOTES below). ​ If a child has already changed state, then these calls return immediately. Otherwise, they block until either a child changes state or a signal handler interrupts the call (assuming that system calls are not automatically restarted using the SA_RESTART flag of sigaction(2)). In the remainder of this page, a child whose state has changed and which has not yet been waited upon by one of these system calls is termed waitable. wait() and waitpid() ​ The wait() system call suspends execution of the calling process until one of its children terminates. The call wait(&amp;status) is equivalent to: ​ waitpid(-1, &amp;status, 0); ​ The waitpid() system call suspends execution of the calling process until a child specified by pid argument has changed state. By default, waitpid() waits only for terminated children, but this behavior is modifiable via the options argument, as described below. ​ The value of pid can be: ​ &lt; -1 meaning wait for any child process whose process group ID is equal to the absolute value of pid. ​ -1 meaning wait for any child process. ​ 0 meaning wait for any child process whose process group ID is equal to that of the calling process. ​ &gt; 0 meaning wait for the child whose process ID is equal to the value of pid. ​ The value of options is an OR of zero or more of the following constants: ​ WNOHANG return immediately if no child has exited. ​ WUNTRACED also return if a child has stopped (but not traced via ptrace(2)). Status for ​ traced children which have stopped is provided even if this option is not speci‐ ​ fied. ​ WCONTINUED (since Linux 2.6.10) ​ also return if a stopped child has been resumed by delivery of SIGCONT. ​ (For Linux-only options, see below.) ​ If status is not NULL, wait() and waitpid() store status information in the int to which it points. This integer can be inspected with the following macros (which take the integer itself as an argument, not a pointer to it, as is done in wait() and waitpid()!): ​ WIFEXITED(status) ​ returns true if the child terminated normally, that is, by calling exit(3) or ​ _exit(2), or by returning from main(). ​ WEXITSTATUS(status) ​ returns the exit status of the child. This consists of the least significant 8 bits ​ of the status argument that the child specified in a call to exit(3) or _exit(2) or as ​ the argument for a return statement in main(). This macro should be employed only if ​ WIFEXITED returned true. ​ WIFSIGNALED(status) ​ returns true if the child process was terminated by a signal. ​ WTERMSIG(status) ​ returns the number of the signal that caused the child process to terminate. This ​ macro should be employed only if WIFSIGNALED returned true. ​ WCOREDUMP(status) ​ returns true if the child produced a core dump. This macro should be employed only if ​ WIFSIGNALED returned true. This macro is not specified in POSIX.1-2001 and is not ​ available on some UNIX implementations (e.g., AIX, SunOS). Only use this enclosed in ​ #ifdef WCOREDUMP … #endif. ​ WIFSTOPPED(status) ​ returns true if the child process was stopped by delivery of a signal; this is possi‐ ​ ble only if the call was done using WUNTRACED or when the child is being traced (see ​ ptrace(2)). ​ WSTOPSIG(status) ​ returns the number of the signal which caused the child to stop. This macro should be ​ employed only if WIFSTOPPED returned true. ​ WIFCONTINUED(status) ​ (since Linux 2.6.10) returns true if the child process was resumed by delivery of SIG‐ ​ CONT. RETURN VALUE ​ wait(): on success, returns the process ID of the terminated child; on error, -1 is returned. ​ waitpid(): on success, returns the process ID of the child whose state has changed; if WNOHANG was specified and one or more child(ren) specified by pid exist, but have not yet changed state, then 0 is returned. On error, -1 is returned. ​ Each of these calls sets errno to an appropriate value in the case of an error. waitpid()好用的地方不在于参数pid，而是参数options。options是个位图，最好用的一个是WNOHANG， WNOHANG return immediately if no child has exited. 即使当前没有任何的child退出，如果加了WNOHANG选项的话，也会立马退出，相当于把waitpid()这个操作由阻塞变成了非阻塞。wait()是阻塞的，但是waitpid()加了WNOHANG选项后可以是非阻塞的。 wait()死等，收一个回来后才能看到是谁，waitpid()可以指定收谁，如果没添加WNOHANG选项，就相当于定向收尸的wait()，死等来收指定pid的子进程，如果添加WNOHANG选项，但子进程还在正常运行或者没达到收尸条件，马上走人，只有子进程结束了，那就收回来。收尸是等进程状态发生变化，才能取出退出码，释放资源，如果一个进程正常运行，收尸是收不回来的。 分组的目的就是统一操作，方便管理。 举个栗子： 写个程序来输出指定范围内的质数，将计算任务分配给子进程来完成，父进程负责收尸。 某次运行结果如下： exec函数族“few” : fork,exec,wait。 父进程创建子进程的时候，是通过复制自己来实现的。 理解exec函数族的核心目的：它们用于在当前进程上下文中执行一个新程序。它们都会替换当前进程的映像，但保留进程ID、打开的文件描述符等。 区分函数：尝试将不同的exec函数与其特定功能关联起来： execl 和 execv：这两个函数允许你传递一个参数列表，其中execl使用可变参数列表，execv使用参数数组。 execle 和 execve：这两个函数除了接受参数列表外，还允许你传递环境变量数组。其中execle使用可变参数列表，execve使用参数数组。 execlp 和 execvp：这两个函数会在PATH环境变量中搜索可执行文件，而不需要提供可执行文件的完整路径。其中execlp使用可变参数列表，execvp使用参数数组。 execve(2) EXECVE(2) NAME ​ execve - execute program SYNOPSIS ​ #include &lt;unistd.h&gt; ​ int execve(const char *filename, char *const argv[], char *const envp[]); DESCRIPTION ​ execve() executes the program pointed to by filename. filename must be either a binary executable, or a script starting with a line of the form: ​ #! interpreter [optional-arg] ​ For details of the latter case, see “Interpreter scripts” below. ​ argv is an array of argument strings passed to the new program. By convention, the first of these strings should contain the filename associated with the file being executed. envp is an array of strings, conventionally of the form key&#x3D;value, which are passed as environment to the new program. Both argv and envp must be terminated by a null pointer. The argument vector and environment can be accessed by the called program’s main function, when it is defined as: ​ int main(int argc, char *argv[], char *envp[]) ​ execve() does not return on success, and the text, data, bss, and stack of the calling process are overwritten by that of the program loaded. RETURN VALUE ​ On success, execve() does not return, on error -1 is returned, and errno is set appropriately. Historical ​ With UNIX V6, the argument list of an exec() call was ended by 0, while the argument list of main was ended by -1. Thus, this argument list was not directly usable in a further exec() call. Since UNIX V7, both are NULL. 注：在《The C Programming Language》中，argv在索引中显示为参数向量，而非参数值。 argc：argument count argv：argument vector envp：environment pointer 编译运行结果如下： exec(3) EXEC(3) NAME ​ execl, execlp, execle, execv, execvp - execute a file SYNOPSIS ​ #include &lt;unistd.h&gt; ​ *extern char *environ; ​ int execl(const char *path, const char *arg, … &#x2F;* (char *) NULL *&#x2F;); ​ int execlp(const char *file, const char *arg, … &#x2F;* (char *) NULL *&#x2F;); ​ int execle(const char *path, const char *arg, … &#x2F;*, (char *) NULL, char * const envp[] *&#x2F;); ​ int execv(const char *path, char *const argv[]); ​ int execvp(const char *file, char *const argv[]); DESCRIPTION ​ The exec() family of functions replaces the current process image with a new process image. The functions described in this manual page are front-ends for execve(2). (See the manual page for execve(2) for further details about the replacement of the current process image.) ​ The initial argument for these functions is the name of a file that is to be executed. ​ The const char *arg and subsequent ellipses in the execl(), execlp(), and execle() functions can be thought of as arg0, arg1, …, argn. Together they describe a list of one or more pointers to null-terminated strings that represent the argument list available to the executed program. The first argument, by convention, should point to the filename associated with the file being executed. The list of arguments must be terminated by a null pointer, and, since these are variadic functions, this pointer must be cast (char *) NULL. ​ The execv(), execvp(), and execvpe() functions provide an array of pointers to null-terminated strings that represent the argument list available to the new program. The first argument, by convention, should point to the filename associated with the file being executed. The array of pointers must be terminated by a null pointer. ​ The execle() and execvpe() functions allow the caller to specify the environment of the executed program via the argument envp. The envp argument is an array of pointers to null-terminated strings and must be terminated by a null pointer. The other functions take the environment for the new process image from the external variable environ in the calling process. RETURN VALUE ​ The exec() functions return only if an error has occurred. The return value is -1, and errno is set to indicate the error. ERRORS ​ All of these functions may fail and set errno for any of the errors specified for execve(2). NOTES ​ On some other systems, the default path (used when the environment does not contain the variable PATH) has the current working directory listed after &#x2F;bin and &#x2F;usr&#x2F;bin, as an anti-Trojan-horse measure. Linux uses here the traditional “current directory first” default path. ​ The behavior of execlp() and execvp() when errors occur while attempting to execute the file is historic practice, but has not traditionally been documented and is not specified by the POSIX standard. BSD (and possibly other systems) do an automatic sleep and retry if ETXTBSY is encountered. Linux treats it as a hard error and returns immediately. ​ Traditionally, the functions execlp() and execvp() ignored all errors except for the ones described above and ENOMEM and E2BIG, upon which they returned. They now return if any error other than the ones described above occurs. 注：前5个exec族函数中，哪些是定长，哪些是可变长参数？ 进程空间搭建的过程中，在exec阶段就已经有了代码段，已初始化数据段，未初始化数据段等，堆和栈是在后来才搭建起来的。 注：在调用execl()函数之前要刷新所有该刷新的数据流。 execl()的第二个参数传参一定要从argv[0]开始。 UNIX世界就是由这三个函数搭建起来的：fork(),exec(),wait()。 编译运行结果如下： 注：argv[0]处的”httpd”类似于一个别名，会显示在进程关系中。这样可以实现木马的一种低级藏身办法，高级一点的可以隐藏在内核模块中，但是这样危害就不如在用户态大了（为啥呀？？？）。 举个栗子：shell的外部命令实现shell的外部命令处理思路【伪代码】： GLOB_NOCHECK If no pattern matches, return the original pattern. By default, glob() returns GLOB_NOMATCH if there are no matches. 守护进程在UNIX系统编程中，经常需要创建守护进程。守护进程一般脱离控制终端，是后台运行的进程，与终端无关。为了使进程完全脱离其父进程和终端，我们需要使用 setsid() 函数来创建新的会话。 注：守护进程一般脱离控制终端，是一个会话的leader，进程组的leader。 setsid(3POSIX) NAME ​ setsid — create session and set process group ID SYNOPSIS ​ #include &lt;unistd.h&gt; ​ pid_t setsid(void); DESCRIPTION ​ The setsid() function shall create a new session, if the calling process is not a process group leader. Upon return the calling process shall be the session leader of this new session, shall be the process group leader of a new process group, and shall have no controlling terminal. The process group ID of the calling process shall be set equal to the process ID of the calling process. The calling process shall be the only process in the new process group and the only process in the new session. RETURN VALUE ​ Upon successful completion, setsid() shall return the value of the new process group ID of the calling process. Otherwise, it shall return −1 and set errno to indicate the error. ERRORS ​ The setsid() function shall fail if: ​ EPERM The calling process is already a process group leader, or the process group ID of a process other than the calling process matches the process ID of the calling process. setsid() 函数用于创建新的会话，并做以下三件事情： 使调用进程成为新会话的领头进程。 使调用进程成为新进程组的领头进程。 使调用进程没有控制终端。 注意事项： 如果调用进程已经是进程组的领头进程，则 setsid() 调用将失败。 为了确保调用进程不是进程组的领头进程，通常首先进行 fork() 操作，然后在子进程中调用 setsid()。这样，父进程可以正常退出，而子进程保证不是进程组的领头进程。 setsid() 使得进程脱离原有的终端、会话和进程组，并建立一个新会话，此时该进程是新会话的领头进程和新进程组的领头进程。 编写原则 创建孤儿进程：创建（fork）一个子进程并使父进程退出（exit），使子进程成为孤儿进程。子进程虽然继承了父进程的进程组ID，但获得了一个新的进程ID，这就保证了子进程不是一个进程组的组长进程。这是后面调用 setsid() 的先决条件。 创建新的会话：调用 setsid() 创建一个新的会话，使调用进程成为新会话的首进程，一个新进程组的组长进程，没有控制终端。 更改工作目录：将守护进程的工作目录更改为根目录（”&#x2F;“），以确保守护进程不会占用其他文件系统的资源。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载。 重设 umask：将 umask 设置为 0，以便守护进程创建的任何文件或目录具有合适的权限。这样可以避免权限问题。 关闭文件描述符：关闭从父进程继承的所有打开的文件描述符。通常，需要循环遍历所有可能的文件描述符，从 0 开始，一直到系统定义的最大文件描述符。 重定向标准文件描述符：使用 open() 系统调用打开 &#x2F;dev&#x2F;null。然后使用 dup2() 系统调用将标准输入、标准输出和标准错误重定向到刚打开的 &#x2F;dev&#x2F;null。这样可以避免输出混乱和不必要的资源占用。 设置信号处理：使用 sigaction() 或 signal() 函数设置适当的信号处理程序，以便守护进程能够优雅地处理系统发送的信号。例如，确保在收到 SIGTERM 信号时守护进程可以正常终止。 启动核心服务：编写守护进程的核心功能，处理任务并在需要时与其他系统组件交互。这可能包括监听套接字、执行周期性任务或监视文件系统更改。 使用锁文件或 PID 文件：使用 open() 和 write() 系统调用创建一个锁文件或 PID 文件，将守护进程的进程 ID 写入其中。这有助于避免同一守护进程的多个实例同时运行，并允许其他进程监视或管理守护进程。 使用系统日志：使用 syslog() 函数将重要信息、错误或警告记录到系统日志，以便管理员能够监视守护进程的状态和活动。这通常包括配置日志优先级、打开日志连接并在创建守护进程时，确保将关键信息、错误或警告记录到系统日志中非常重要。 注： （1）PID，PGID，SID三者一致，父进程为1号进程，且脱离终端，可知某进程是否为守护进程 （2）ps axj显示结果中的TTY栏，”?”表示脱离控制终端。 举个栗子： 以守护进程的方式，每隔1秒，向指定文件中写入指定格式的当前系统时间： 注：运行时需要root权限，杀死该进程：sudo killall mydaemon。 通过ps axj指令查看mydaemon进程为守护进程，通过sudo tail -f &#x2F;var&#x2F;log&#x2F;mydaemon.log动态查看文件内容。 系统日志每个应用程序都有必要写系统日志，但不是每一个程序都有权限去写，所以都把内容提交给syslogd服务，由它统一去写。权限分割。 SYSLOG(3) NAME ​ closelog, openlog, syslog - send messages to the system logger SYNOPSIS ​ #include &lt;syslog.h&gt; ​ void openlog(const char *ident, int option, int facility); ​ void syslog(int priority, const char *format, …); ​ void closelog(void); DESCRIPTION ​ openlog() opens a connection to the system logger for a program. ​ The string pointed to by ident is prepended to every message, and is typically set to the program name. If ident is NULL, the program name is used. (POSIX.1-2008 does not specify the behavior when ident is NULL.) ​ The option argument specifies flags which control the operation of openlog() and subsequent calls to syslog(). The facility argument establishes a default to be used if none is specified in subsequent calls to syslog(). The values that may be specified for option and facility are described below. ​ The use of openlog() is optional; it will automatically be called by syslog() if necessary, in which case ident will default to NULL. ​ syslog() generates a log message, which will be distributed by syslogd(8). ​ The priority argument is formed by ORing together a facility value and a level value (described below). If no facility value is ORed into priority, then the default value set by openlog() is used, or, if there was no preceding openlog() call, a default of LOG_USER is employed. ​ The remaining arguments are a format, as in printf(3), and any arguments required by the format, except that the two-character sequence %m will be replaced by the error message string strerror(errno). The format string need not include a terminating newline character. ​ closelog() closes the file descriptor being used to write to the system logger. The use of closelog() is optional. openlog(3)openlog() 函数用于打开与系统日志守护进程的连接。它允许设置日志选项、指定消息来源标识符和定义消息设施。函数原型如下： 参数说明： ident：一个字符串，用作消息来源的标识符。此字符串将添加到每条日志消息的开头。 option：一个位掩码，用于设置日志选项。例如，LOG_CONS（如果消息无法发送到系统日志，则将其写入控制台）、LOG_PID（在每条消息中包含调用进程的进程 ID）、LOG_NDELAY（立即打开与系统日志的连接，而不是在写入第一条消息时）等。 facility：一个整数，表示消息的来源类型。例如，LOG_USER（用户级消息）、LOG_LOCAL0（本地使用的设施 0）、LOG_DAEMON（系统守护进程）等。 示例：openlog(“my_daemon”, LOG_PID | LOG_CONS, LOG_DAEMON); syslog(3)syslog() 函数用于向系统日志写入日志消息。它接受一个整数优先级和一个格式化字符串作为参数，以及与格式化字符串中的格式说明符对应的可变参数列表。函数原型如下： 参数说明： priority：消息的优先级，由一个或多个日志级别（例如，LOG_ERR、LOG_WARNING）和一个日志设施（例如，LOG_USER、LOG_DAEMON）组成。日志级别和日志设施可以使用按位或运算符（|）组合。 format：一个格式化字符串，类似于 printf() 函数使用的字符串。它可以包含格式说明符（例如，%s、%d），以及用于描述消息内容的文本。 ...：可变参数列表，与格式字符串中的格式说明符相对应。 示例：syslog(LOG_ERR | LOG_USER, “An error occurred: %s”, error_message); closelog(3)closelog() 函数用于关闭与系统日志守护进程的连接。在程序结束时调用此函数是一种良好的做法，尽管在程序退出时，资源会自动释放。 举个栗子： 在运行此示例程序后，可以在系统日志中找到相应的日志记录。在许多 Linux 发行版中，这些记录可以在 /var/log/syslog 或 /var/log/messages 文件中找到。 "},{"title":"钩子函数|进程的终止方式","date":"2023-08-17T16:00:00.000Z","url":"/2023/08/18/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/","tags":[["system programming","/tags/system-programming/"]],"categories":[["《系统编程实践（C语言版）》","/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/"]],"content":"​ 主要介绍（1）进程的终止方式；（2）钩子函数 注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数） 进程的终止​ 进程的终止方式可分为以下5种正常终止方式和3种异常终止方式： 正常终止： ​ 从main函数返回； ​ 调用exit； ​ 调用_exit或_Exit； ​ 最后一个线程从其启动例程返回； ​ 最后一个线程调用pthread_exit； 异常终止： ​ 调用abort； ​ 接到一个信号并终止； ​ 最后一个线程对其取消请求作出响应； 调用exit EXIT(3) NAME ​ exit - cause normal process termination SYNOPSIS ​ #include &lt;stdlib.h&gt; ​ void exit(int status); DESCRIPTION ​ The exit() function causes normal process termination and the value of status &amp; 0377 is returned to the parent (see wait(2)). ​ All functions registered with atexit(3) and on_exit(3) are called, in the reverse order of their registration. (It is possible for one of these functions to use atexit(3) or on_exit(3) to register an additional function to be executed during exit processing; the new registration is added to the front of the list of functions that remain to be called.) If one of these functions does not return (e.g., it calls _exit(2), or kills itself with a signal), then none of the remaining functions is called, and further exit processing (in particular, flushing of stdio(3) streams) is abandoned. If a function has been registered multiple times using atexit(3) or on_exit(3), then it is called as many times as it was registered. ​ All open stdio(3) streams are flushed and closed. Files created by tmpfile(3) are removed. ​ The C standard specifies two constants, EXIT_SUCCESS and EXIT_FAILURE, that may be passed to exit() to indicate successful or unsuccessful termination, respectively. RETURN VALUE ​ The exit() function does not return. status &amp; 0377：exit()能带回去的值就只有256种，-128~127。 _exit&#x2F;_Exit _EXIT(2) NAME ​ _exit, _Exit - terminate the calling process SYNOPSIS ​ #include &lt;unistd.h&gt; ​ void _exit(int status); ​ #include &lt;stdlib.h&gt; ​ void _Exit(int status); DESCRIPTION ​ The function _exit() terminates the calling process “immediately”. Any open file descriptors belonging to the process are closed; any children of the process are inherited by process 1, init, and the process’s parent is sent a SIGCHLD signal. ​ The value status is returned to the parent process as the process’s exit status, and can be collected using one of the wait(2) family of calls. ​ The function _Exit() is equivalent to _exit(). RETURN VALUE ​ These functions do not return. 调用_exit&#x2F;_Exit函数，不执行钩子函数，也不执行IO清理的。 什么时候用exit()，什么时候用_exit()&#x2F;_Exit()？ 只要出错了然后什么都不敢动了，调用_exit()&#x2F;_Exit()；该刷新的，正常结束的，调用exit()。 （以下用伪码表示） 如果f值不是0&#x2F;1&#x2F;2种的任何一种，有理由怀疑调用func()后，switch(f)语句前，这两个语句中间的代码出现问题，多半是写越界，把f变量的空间给覆盖写了。如果此时调用exit()函数，执行各种钩子函数，同步刷新IO等可能会扩大故障，这时候可以用_exit()，直接退出，不执行钩子函数，不刷新IO操作。当然也可以用信号，比如调用abort()，给当前进程发送signal abort信号，把自己杀死，顺便得到一个出错的现场，来分析这个现场是什么原因导致f值出现第四种情况。 钩子函数 ATEXIT(3) NAME ​ atexit - register a function to be called at normal process termination SYNOPSIS ​ #include &lt;stdlib.h&gt; ​ int atexit(void (*function)(void)); DESCRIPTION ​ The atexit() function registers the given function to be called at normal process termination, either via exit(3) or via return from the program’s main(). Functions so registered are called in the reverse order of their registration; no arguments are passed. ​ The same function may be registered multiple times: it is called once for each registration. ​ POSIX.1 requires that an implementation allow at least ATEXIT_MAX (32) such functions to be registered. The actual limit supported by an implementation can be obtained using sysconf(3). ​ When a child process is created via fork(2), it inherits copies of its parent’s registrations. Upon a successful call to one of the exec(3) functions, all registrations are removed. RETURN VALUE ​ The atexit() function returns the value 0 if successful; otherwise it returns a nonzero value. atexit()函数（俗称钩子函数）用于注册在程序正常退出时要执行的函数。函数原型如下： 参数说明： function：指向要在程序退出时执行的函数的指针。这个函数没有参数和返回值。 函数返回值： 如果成功注册要执行的函数，返回值为0。 如果注册失败，返回一个非零值。 注意事项： 只要是用到申请资源的内容，下面就可以挂上钩子函数，把它的逆操作挂上去。 注册的函数会以注册的顺序的逆序执行，也就是最后注册的函数会最先执行。 可以多次调用 atexit() 函数，以便在程序退出时依次执行多个函数。 如果程序因为异常或调用了 abort() 等函数导致非正常退出，那么通过 atexit() 注册的清理函数将不会被执行。 举个栗子： 编译运行结果如下： "},{"title":"解析命令行参数","date":"2023-08-17T02:49:50.000Z","url":"/2023/08/17/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90/","tags":[["system programming","/tags/system-programming/"]],"categories":[["《系统编程实践（C语言版）》","/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/"]],"content":"主要介绍解析命令行参数的两个函数：getopt()，getopt_long() 注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数） man手册 NAME ​ getopt, getopt_long - Parse command-line options SYNOPSIS ​ #include &lt;unistd.h&gt; ​ int getopt(int argc, char * const argv[], const char *optstring); ​ extern char *optarg; ​ extern int optind, opterr, optopt; ​ #include &lt;getopt.h&gt; ​ int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); ​ int getopt_long_only(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); DESCRIPTION The getopt() function parses the command-line arguments. Its arguments argc and argv are the argument count and array as passed to the main() function on program invocation. An element of argv that starts with ‘-‘ (and is not exactly “-“ or “–”) is an option element. The characters of this element (aside from the initial ‘-‘) are option characters. If getopt() is called repeatedly, it returns successively each of the option characters from each of the option elements. The variable optind is the index of the next element to be processed in argv. The system initializes this value to 1. The caller can reset it to 1 to restart scanning of the same argv, or when scanning a new argument vector. If getopt() finds another option character, it returns that character, updating the external variable optind and a static variable nextchar so that the next call to getopt() can resume the scan with the following option character or argv-element. If there are no more option characters, getopt() returns -1. Then optind is the index in argv of the first argv-element that is not an option. optstring is a string containing the legitimate option characters. If such a character is followed by a colon, the option requires an argument, so getopt() places a pointer to the following text in the same argv-element, or the text of the following argv-element, in optarg. Two colons mean an option takes an optional arg; if there is text in the current argv-element (i.e., in the same word as the option name itself, for example, “-oarg”), then it is returned in optarg, otherwise optarg is set to zero. This is a GNU extension. If optstring contains W followed by a semicolon, then -W foo is treated as the long option –foo. (The -W option is reserved by POSIX.2 for implementation extensions.) This behavior is a GNU extension, not available with libraries before glibc 2. By default, getopt() permutes the contents of argv as it scans, so that eventually all the nonoptions are at the end. Two other modes are also implemented. If the first character of optstring is ‘+’ or the environment variable POSIXLY_CORRECT is set, then option processing stops as soon as a nonoption argument is encountered. If the first character of optstring is ‘-‘, then each nonoption argv-element is handled as if it were the argument of an option with character code 1. (This is used by programs that were written to expect options and other argv-elements in any order and that care about the ordering of the two.) The special argument “–” forces an end of option-scanning regardless of the scanning mode. If getopt() does not recognize an option character, it prints an error message to stderr, stores the character in optopt, and returns ‘?’. The calling program may prevent the error message by setting opterr to 0. If getopt() finds an option character in argv that was not included in optstring, or if it detects a missing option argument, it returns ‘?’ and sets the external variable optopt to the actual option character. If the first character (following any optional ‘+’ or ‘-‘ described above) of optstring is a colon (‘:’), then getopt() returns ‘:’ instead of ‘?’ to indicate a missing option argument. If an error was detected, and the first character of optstring is not a colon, and the external variable opterr is nonzero (which is the default), getopt() prints an error message. ​ getopt_long() and getopt_long_only() The getopt_long() function works like getopt() except that it also accepts long options, started with two dashes. (If the program accepts only long options, then optstring should be specified as an empty string (“”), not NULL.) Long option names may be abbreviated if the abbreviation is unique or is an exact match for some defined option. A long option may take a parameter, of the form –arg&#x3D;param or –arg param. longopts is a pointer to the first element of an array of struct option declared in &lt;getopt.h&gt; as ​ struct option { ​ const char *name; ​ int has_arg; ​ int *flag; ​ int val; ​ }; The meanings of the different fields are: ​ name is the name of the long option. ​ has_arg is: no_argument (or 0) if the option does not take an argument; required_argument (or 1) if the option requires an argument; or optional_argument (or 2) if the option takes an optional argument. ​ flag specifies how results are returned for a long option. If flag is NULL, then getopt_long() returns val. (For example, the calling program may set val to the equivalent short option character.) Otherwise, getopt_long() returns 0, and flag points to a variable which is set to val if the option is found, but left unchanged if the option is not found. ​ val is the value to return, or to load into the variable pointed to by flag. ​ The last element of the array has to be filled with zeros. ​ If longindex is not NULL, it points to a variable which is set to the index of the long option relative to longopts. getopt_long_only() is like getopt_long(), but ‘-‘ as well as “–” can indicate a long option. If an option that starts with ‘-‘ (not “–”) doesn’t match a long option, but does match a short option, it is parsed as a short option instead. RETURN VALUE If an option was successfully found, then getopt() returns the option character. If all command-line options have been parsed, then getopt() returns -1. If getopt() encounters an option character that was not in optstring, then ‘?’ is returned. If getopt() encounters an option with a missing argument, then the return value depends on the first character in optstring: if it is ‘:’, then ‘:’ is returned; otherwise ‘?’ is returned. getopt_long() and getopt_long_only() also return the option character when a short option is recognized. For a long option, they return val if flag is NULL, and 0 otherwise. Error and -1 returns are the same as for getopt(), plus ‘?’ for an ambiguous match or an extraneous parameter. getopt(3)getopt() 函数用于解析命令行参数并返回对应的选项和参数。函数原型如下： 参数说明： argc：命令行参数个数，包括程序名本身。 argv：指向命令行参数字符串数组的指针，其中包括程序名和各个参数。 optstring：包含所有有效选项的字符串，表示程序所支持的命令行选项。optstring中的每个字符表示一个选项： 大写字母表示可以带参数的选项； 小写字母表示不带参数的选项； 冒号（:）表示该选项必须带一个参数； optarg：指向当前选项参数的指针。当 getopt() 解析到带有参数的选项时，可以通过访问 optarg 来获取该参数的值。 optind：表示下一个要处理的参数索引。初始值为 1，每次调用 getopt() 后会自动更新，程序名、选项及其参数占据前几个位置，之后才是剩余参数。 opterr：控制是否显示错误信息。如果设置为 0，getopt() 函数将不会打印错误信息到标准错误流（stderr）；如果设置为非零值，getopt() 函数将会打印错误信息到 stderr。 optopt：用于保存无效选项字符（即不在 optstring 中的字符），以便在需要时进行处理。 函数返回值： 如果找到合法选项，则返回选项的ASCII码。 如果所有的命令行选项都解析完毕，则返回-1。 如果遇到非法选项字符，则返回?，并将 optopt 变量设为非法选项字符的ASCII码。 注意事项： 当 getopt() 函数返回一个选项代码时，全局变量 optarg 将指向选项的参数，全局变量 optind 将指向下一个待处理的命令行参数的位置。 注意区分以下概念：选项、参数、选项参数、非选项参数。 举个栗子： task：以指定格式显示当前系统时间。 注：实现mydate.c程序时，可以按照如下顺序：mdMS，Hy，非选项的传参，文件的操作。 getopt_long(3)getopt_long() 函数与getopt() 函数类似，也是用于解析命令行参数的函数。但相较于getopt()，它支持更复杂的选项处理，包括长选项（长格式的命令行选项，例如 --help）以及更多的自定义配置。函数原型如下： 参数说明： argc：命令行参数个数，包括程序名本身。 argv：指向命令行参数字符串数组的指针，其中包括程序名和各个参数。 optstring：类似于getopt() 的选项字符串，表示程序所支持的短选项。 longopts：一个指向struct option类型的数组，表示程序所支持的长选项。数组中的每个元素都是一个 option 结构体，其定义如下： longindex：用于返回当前长选项在longopts数组中的索引，通常可设置为 NULL。 函数返回值： 如果找到合法选项，返回选项的短选项字符或者长选项的val字段。 如果所有命令行选项都解析完毕，则返回-1。 如果遇到非法选项字符或者无法匹配的长选项，则返回?。 注意事项： 在选项数组（option array）中，最后一个元素必须全部填充为零，表示数组的结束。 "},{"title":"第五章：线程相关函数","date":"2023-08-16T10:36:59.000Z","url":"/2023/08/16/Chapter5_%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/","tags":[["system programming","/tags/system-programming/"]],"categories":[["《系统编程实践（C语言版）》","/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/"]],"content":"介绍线程相关的一些重要函数 注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数） 线程的概念线程就是一个正在运行的函数。（进程就是容器，用来承载线程） POSIX线程是一套标准，而不是实现。 线程标识：pthread_t 中的”p”表示POSIX，数据类型不确定，因为各家实现不一样，有可能是整型，有可能是结构体，还有可能是typedef出来的指针类型。 ps axf：查看进程关系 ps axm：查看每个进程的线程 ps ax -L：以列表形式查看进程与线程关系； -L: Show threads, possibly with LWP and NLWP columns. m: Show threads after processes. 信号机制和多线程机制可以在小范围内混用，不建议大范围内混用。 pthread_equal(3)在线程编程中，线程标识符是用来唯一标识一个线程的值，类似于进程ID（PID）用于唯一标识一个进程。pthread_equal() 函数用于比较两个线程标识符是否相等，从而判断两个线程是否是同一个线程。函数原型如下： 参数说明： thread1和thread2：两个线程标识符，类型为pthread_t。这两个参数将被用来比较是否表示同一个线程。 函数返回值： 如果thread1和thread2表示同一个线程，函数返回值为非零值（通常为1）。 如果thread1和thread2表示不同的线程，函数返回值为0。 注意事项： pthread_equal() 函数可以用来检查两个线程标识符是否相等，但并不是所有情况下都需要使用它。大多数情况下，你不需要直接比较线程标识符，而是通过线程同步机制来确保线程之间的正确协作。 在实际编程中，尽量避免直接使用 pthread_equal() 来做逻辑判断，因为它可能会引入不必要的复杂性和风险。更好的方法是使用互斥锁、条件变量等线程同步机制来控制线程的执行顺序和协作。 pthread_self(3)pthread_self() 函数用于获取当前调用线程的线程标识符。函数原型如下： 函数返回值： 返回值是一个pthread_t 类型的值，表示调用线程的线程标识符。 注意事项： pthread_self() 函数返回的线程标识符是一个内部表示，通常是一个指针或数字。在不同的操作系统和编译器中，它可能采用不同的方式来表示线程标识符。因此，最好不要将线程标识符作为具体的数值来进行比较或操作。 线程的创建pthread_create(3)pthread_create()函数用于创建一个新的线程，函数原型如下： 参数说明： thread：指向 pthread_t 类型变量的指针，用于保存新线程的标识符。 attr：指向 pthread_attr_t 类型变量的指针，用于指定新线程的属性，例如线程的栈大小、线程优先级等。如果为 NULL，则使用默认线程属性。 start_routine：线程函数的指针，新线程将从这个函数开始执行。 arg：传递给线程函数的参数。 函数返回值： 若成功，返回0；否则，返回错误编号（error number）。 On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined. （man手册） 举个栗子： 编译运行结果如下： 注：线程的调度取决于调度器策略 编译也可以通过包含以下内容的makefile文件来实现： 不用写成类似于gcc pthread_create.c -pthread，直接make pthread_create即可。 线程的终止： （1）线程从启动例程返回，返回值就是线程的退出码； （2）线程可以被同一进程中的其他线程取消； （3）线程调用pthread_exit()函数；（该函数会结束调用线程） 【man手册：】 The new thread terminates in one of the following ways: It calls pthread_exit(3), specifying an exit status value that is available to another thread in the same process that calls pthread_join(3). It returns from start_routine(). This is equivalent to calling pthread_exit(3) with the value supplied in the return statement. It is canceled (see pthread_cancel(3)). Any of the threads in the process calls exit(3), or the main thread performs a return from main(). This causes the termination of all threads in the process. 线程的终止pthread_exit(3)pthread_exit()函数用于终止当前线程的执行，并返回一个退出状态给线程的调用者。它允许线程在完成任务或遇到特定条件时自行终止，而不影响其他线程。函数原型如下： 参数说明： retval：一个指向任意类型数据的指针，表示线程的退出状态。在多线程环境下，线程的退出状态可以是一个任意类型的数据，用于向其他线程传递信息。 注意事项： 使用 pthread_exit() 函数可以避免线程突然终止，从而防止线程资源泄漏和未完成的操作。 在调用 pthread_exit() 函数之后，当前线程会立即终止，并不会执行 pthread_join() 函数等待其他线程完成。 被终止的线程的资源会被系统回收，但其他线程仍会继续运行。 在多线程程序中，如果某个线程使用 pthread_exit() 终止了，整个程序可能还会继续执行，直到所有线程都完成或被终止。 举个栗子： 编译运行结果如下： pthread_join(3)pthread_join()函数用于等待指定的线程结束，并获取它的退出状态。函数原型如下： 参数说明： thread：要等待的线程的标识符，通常是通过调用 pthread_create() 函数创建的线程。 retval：一个指向指针的指针，用于存储被等待线程的退出状态。这个参数允许线程传递一个指向任意数据类型的指针作为退出状态。 函数返回值： On success, pthread_join() returns 0; on error, it returns an error number. 注意事项： 如果不关心线程的退出状态，可以将 retval 参数设置为 NULL。 如果指定的线程已经结束，那么 pthread_join() 函数会立即返回，并返回 0 作为函数值。如果指定的线程还未结束，那么 pthread_join() 函数会一直阻塞，直到线程结束为止。 注：pthread_join()函数功能类似于wait()函数，收尸。 在多线程编程中，线程的退出状态通常用来表示线程的执行结果，可以通过 pthread_exit() 函数返回给线程的调用者，或者通过 pthread_join() 函数获取。在某些情况下，我们可能需要在线程中传递一些复杂的数据结构，如结构体、指针等，来描述线程的执行结果。此时，我们可以将这些数据结构作为指针传递给线程函数，让线程函数负责修改这些数据结构，并通过 pthread_exit() 函数或全局变量等方式将其返回给线程的调用者。 举个栗子： 以下是一个简单的例子，演示如何在线程中传递指针来描述线程的执行结果： 编译运行结果如下： 栈的清理pthread_cleanup_push()，pthread_cleanup_pop() 都是宏，作用类似于钩子函数。 注：gcc xxx.c -E可以判断xxx.c文件中哪些是宏&#x2F;条件编译，预处理后剩下的内容。 NAME ​ pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation clean-up handlers SYNOPSIS ​ #include &lt;pthread.h&gt; ​ void pthread_cleanup_push(void (*routine)(void *), void *arg); ​ void pthread_cleanup_pop(int execute); ​ Compile and link with -pthread. DESCRIPTION ​ These functions manipulate the calling thread’s stack of thread-cancellation clean-up handlers. A clean-up handler is a function that is automatically executed when a thread is canceled (or in various other circumstances described below); it might, for example, unlock a mutex so that it becomes available to other threads in the process. ​ The pthread_cleanup_push() function pushes routine onto the top of the stack of clean-up handlers. When routine is later invoked, it will be given arg as its argument. ​ The pthread_cleanup_pop() function removes the routine at the top of the stack of clean-up handlers, and optionally executes it if execute is nonzero. ​ A cancellation clean-up handler is popped from the stack and executed in the following circumstances: ​ 1. When a thread is canceled, all of the stacked clean-up handlers are popped and executed in the reverse of the order in which they were pushed onto the stack. ​ 2. When a thread terminates by calling pthread_exit(3), all clean-up handlers are executed as described in the preceding point. (Clean-up handlers are not called if the thread terminates by performing a return from the thread start function.) ​ 3. When a thread calls pthread_cleanup_pop() with a nonzero execute argument, the top-most clean-up handler is popped and executed. ​ POSIX.1 permits pthread_cleanup_push() and pthread_cleanup_pop() to be implemented as macros that expand to text containing ‘{‘ and ‘}’, respectively. For this reason, the caller must ensure that calls to these functions are paired within the same function, and at the same lexical nesting level. (In other words, a clean-up handler is established only during the execution of a specified section of code.) RETURN VALUE ​ These functions do not return a value. 在指定的代码段执行期间才会建立清理处理程序。在执行过程中，可以使用 pthread_cleanup_push() 函数将清理处理程序压入堆栈，并在代码段执行结束时使用 pthread_cleanup_pop() 函数将其弹出。这种机制确保了清理处理程序只在特定代码段的执行过程中存在，并在其执行结束后自动弹出。这种机制在多线程编程中非常有用，可以确保线程在任何情况下都能够正常地终止并释放资源。 pthread_cleanup_push(3)pthread_cleanup_push() 函数用于为线程设置清理处理程序（clean-up handler）。该函数可以将一个清理处理程序绑定到线程，当线程退出时，清理处理程序会被调用。函数原型如下： 参数说明： routine：一个函数指针，指向清理处理程序函数，这个函数在线程退出时会被调用。它的原型应该是 void function_name(void *arg)。 arg：传递给清理处理程序函数的参数，类型是void *。这可以是指向某个资源或状态的指针，以便在清理处理程序中进行适当的操作。 pthread_cleanup_pop(3)pthread_cleanup_pop() 函数用于指定清理处理程序的执行条件。函数原型如下： 参数说明： execute：一个整数值，用于指定是否执行清理处理程序。非零值表示执行，零值表示不执行。 注意事项： pthread_cleanup_push() 函数必须与 pthread_cleanup_pop() 成对使用。每次调用 pthread_cleanup_push() 函数都应该紧接着调用相应的 pthread_cleanup_pop() 函数。 当线程调用pthread_exit()、pthread_cancel()、pthread_cleanup_pop() 或者线程函数返回时，绑定在该线程上的清理处理程序会被按照它们被创建时的相反顺序执行。 清理处理程序的执行条件是由线程库在特定条件下自动执行的，而不是由线程程序员显式调用的。清理处理程序通常用于资源释放、内存清理等工作，以确保在线程退出时不会造成资源泄漏。 举个栗子： 编译运行结果如下： 线程的取消pthread_cancel(3)注：要结束正在运行的线程，先把线程取消，再收尸。就跟wait()函数给进程收尸一样，正在运行的内容是没办法收尸收回来的。 调用 pthread_cancel() 函数会向指定的线程发送取消请求，但并不保证该线程会立即退出，而是在接下来的某个取消点（cancellation point）执行取消操作。线程会在适当的时候检查取消请求，并调用相应的清理处理函数。这些清理处理函数可以通过调用 pthread_cleanup_push() 和 pthread_cleanup_pop() 函数来注册。 NAME ​ pthread_cancel - send a cancellation request to a thread SYNOPSIS ​ #include &lt;pthread.h&gt; ​ int pthread_cancel(pthread_t thread); ​ Compile and link with -pthread. DESCRIPTION ​ The pthread_cancel() function sends a cancellation request to the thread thread. Whether and when the target thread reacts to the cancellation request depends on two attributes that are under the control of that thread: its cancelability state and type. ​ A thread’s cancelability state, determined by pthread_setcancelstate(3), can be enabled (the default for new threads) or disabled. If a thread has disabled cancellation, then a cancellation request remains queued until the thread enables cancellation. If a thread has enabled cancellation, then its cancelability type determines when cancellation occurs. ​ A thread’s cancellation type, determined by pthread_setcanceltype(3), may be either asynchronous or deferred (the default for new threads). Asynchronous cancelability means that the thread can be canceled at any time (usually immediately, but the system does not guarantee this). Deferred cancelability means that cancellation will be delayed until the thread next calls a function that is a cancellation point. A list of functions that are or may be cancellation points is provided in pthreads(7). ​ When a cancellation requested is acted on, the following steps occur for thread (in this order): ​ 1. Cancellation clean-up handlers are popped (in the reverse of the order in which they were pushed) and called. (See pthread_cleanup_push(3).) ​ 2. Thread-specific data destructors are called, in an unspecified order. (See pthread_key_create(3).) ​ 3. The thread is terminated. (See pthread_exit(3).) ​ The above steps happen asynchronously with respect to the pthread_cancel() call; the return status of pthread_cancel() merely informs the caller whether the cancellation request was successfully queued. ​ After a canceled thread has terminated, a join with that thread using pthread_join(3) obtains PTHREAD_CANCELED as the thread’s exit status. (Joining with a thread is the only way to know that cancellation has completed.) RETURN VALUE ​ On success, pthread_cancel() returns 0; on error, it returns a nonzero error number. 取消有2种状态：允许和不允许。 允许取消可分为：异步cancel；推迟cancel（默认）-&gt; 推迟至cancel点再响应 cancel点：POSIX定义的cancel点，都是可能引发阻塞的系统调用。而非系统调用的内容是不是cancel点，各个平台定义有所区别。 注意事项： pthread_cancel() 函数并不保证线程会立即终止，而是发送一个取消请求。实际的取消发生可能会受到线程当前的状态和取消点的影响。 线程可以选择是否响应取消请求，它可以在取消点进行响应，也可以选择忽略取消请求。 线程可以通过调用pthread_setcancelstate() 函数来设置线程是否允许取消，以及在取消点是否响应取消。 举个栗子： 以下代码片段中，如果在第一次open()操作执行成功后，第二次open()操作执行前被中断，那close()操作将无法执行。 可以挂钩子函数： 如果前面成功了，但刚好在挂钩子函数之前就被取消了，这种情况是不会发生的。 pthread_testcancel(3) NAME pthread_testcancel - request delivery of any pending cancellation request SYNOPSIS #include &lt;pthread.h&gt; ​ void pthread_testcancel(void); ​ Compile and link with -pthread. DESCRIPTION Calling pthread_testcancel() creates a cancellation point within the calling thread, so that a thread that is otherwise executing code that contains no cancellation points will respond to a cancellation request. ​ If cancelability is disabled (using pthread_setcancelstate(3)), or no cancellation request is pending, then a call to pthread_testcancel() has no effect. RETURN VALUE This function does not return a value. If the calling thread is canceled as a consequence of a call to this function, then the function does not return. 注：在多线程编程中，取消请求是用来请求终止一个线程的操作，但是实际终止时间是由线程在取消点检查取消请求后决定的。 pthread_testcancel() 函数通常被用作取消点（cancellation point），检查是否有取消请求被发送。如果有取消请求，则线程会在此处终止执行，之后的代码将不再执行。函数原型如下： 注意事项： 在程序中使用pthread_testcancel() 函数时，通常需要与pthread_setcancelstate() 函数和pthread_setcanceltype() 函数一起使用，以确保线程在取消点检查取消请求。 举个栗子： 在上面的示例中，pthread_testcancel() 函数被用作取消点，用于在线程中检查是否有取消请求。在调用这个函数后，如果有取消请求，线程将终止。 pthread_setcancelstate(3) NAME ​ pthread_setcancelstate, pthread_setcanceltype - set cancelability state and type SYNOPSIS ​ #include &lt;pthread.h&gt; ​ int pthread_setcancelstate(int state, int *oldstate); ​ int pthread_setcanceltype(int type, int *oldtype); ​ Compile and link with -pthread. DESCRIPTION ​ The pthread_setcancelstate() sets the cancelability state of the calling thread to the value given in state. The previous cancelability state of the thread is returned in the buffer pointed to by oldstate. The state argument must have one of the following values: ​ PTHREAD_CANCEL_ENABLE The thread is cancelable. This is the default cancelability state in all new threads, including the initial thread. The thread’s cancelability type determines when a cancelable thread will respond to a cancellation request. ​ PTHREAD_CANCEL_DISABLE The thread is not cancelable. If a cancellation request is received, it is blocked until cancelability is enabled. ​ The pthread_setcanceltype() sets the cancelability type of the calling thread to the value given in type. The previous cancelability type of the thread is returned in the buffer pointed to by oldtype. The type argument must have one of the following values: ​ PTHREAD_CANCEL_DEFERRED A cancellation request is deferred until the thread next calls a function that is a cancellation point (see pthreads(7)). This is the default cancelability type in all new threads, including the initial thread. ​ PTHREAD_CANCEL_ASYNCHRONOUS The thread can be canceled at any time. (Typically, it will be canceled immediately upon receiving a cancellation request, but the system doesn’t guarantee this.) ​ The set-and-get operation performed by each of these functions is atomic with respect to other threads in the process calling the same function. RETURN VALUE ​ On success, these functions return 0; on error, they return a nonzero error number. pthread_setcancelstate() 函数用于设置线程的取消状态。线程可以设置是否允许取消请求（cancellation request）对其进行取消。函数原型如下： 参数说明： state：一个整数值，表示要设置的取消状态。可以是以下值之一： PTHREAD_CANCEL_ENABLE：允许取消请求（默认值）。 PTHREAD_CANCEL_DISABLE：禁止取消请求。 oldstate：一个指向整数的指针，用于存储之前的取消状态。如果不关心之前的状态，可以将此参数设置为 NULL。 函数返回值： 若成功设置取消状态，函数返回值为0；若发生错误，返回一个非零的错误码。 注意事项： 取消状态仅影响线程是否对取消请求进行响应，实际的取消点和取消类型也会影响线程的终止。 在调用 pthread_create() 创建线程之前，可以使用 pthread_setcancelstate() 来设置线程的取消状态。 pthread_setcanceltype(3)pthread_setcanceltype() 函数用于设置线程的取消类型。线程的取消类型决定了在取消点检查取消请求时，线程如何响应取消请求。函数原型如下： 参数说明： type：一个整数值，表示要设置的取消类型。可以是以下值之一： PTHREAD_CANCEL_ASYNCHRONOUS：立即响应取消请求。 PTHREAD_CANCEL_DEFERRED：只有在下一个取消点时响应取消请求（默认值）。 oldtype：一个指向整数的指针，用于存储之前的取消类型。如果不关心之前的类型，可以将此参数设置为 NULL。 函数返回值： 若成功设置取消类型，函数返回值为0；若发生错误，返回一个非零的错误码。 注意事项： 取消类型会影响线程在取消点检查取消请求时的响应，以及线程是否会在取消点终止执行。 在调用 pthread_create() 创建线程之前，可以使用 pthread_setcanceltype() 来设置线程的取消类型。 pthread_detach(3) NAME ​ pthread_detach - detach a thread SYNOPSIS ​ #include &lt;pthread.h&gt; ​ int pthread_detach(pthread_t thread); ​ Compile and link with -pthread. DESCRIPTION ​ The pthread_detach() function marks the thread identified by thread as detached. When a detached thread terminates, its resources are automatically released back to the system without the need for another thread to join with the terminated thread. ​ Attempting to detach an already detached thread results in unspecified behavior. RETURN VALUE ​ On success, pthread_detach() returns 0; on error, it returns an error number. ERRORS ​ EINVAL thread is not a joinable thread. ​ ESRCH No thread with the ID thread could be found. 在线程编程中，有两种状态：分离状态和非分离状态。分离状态的线程在退出后会自动释放资源，而非分离状态的线程需要通过pthread_join() 来获取返回值并释放资源。 pthread_detach() 函数用于将一个线程标记为“分离状态”，从而使得线程在退出时能够自动释放其资源，无需显式调用 pthread_join() 来等待其它线程获取返回值。函数原型如下： 参数说明： thread：要被标记为分离状态的线程的标识符，类型为pthread_t。 函数返回值： 若成功将线程标记为分离状态，函数返回值为0；若发生错误，返回一个非零的错误码。 注意事项： 只能对还没有被其他线程调用 pthread_join() 的线程进行分离操作。 在线程标记为分离状态之后，不能再次对其进行分离或者非分离操作。 "},{"title":"第五章：线程同步机制","date":"2023-08-15T10:36:59.000Z","url":"/2023/08/15/Chapter5_%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/","tags":[["system programming","/tags/system-programming/"]],"categories":[["《系统编程实践（C语言版）》","/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/"]],"content":"主要介绍线程同步的三种方式：互斥量、条件变量、信号量 注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数） 线程竞争使用20个线程分别对同一个文件进行如下操作：打开，读取数据，加1，覆盖写回去，关闭文件。 某次编译运行的结果如下： 多个线程同时对同一个文件进行读写操作，如果线程之间没有进行同步操作，可能导致文件中的数据错乱或者不确定的结果，因为对文件的读写操作不一定是原子的。 多线程的并发操作中，往往需要使用线程同步机制来保护对共享资源（如文件）的访问，以避免数据竞争和不确定的结果。 互斥量互斥量（mutex，mutual exclusion）是一种用于线程同步的机制，它可以用来保护共享资源的访问。在多线程程序中，多个线程可能同时访问同一个共享资源，如果没有同步机制，就会导致竞争条件（race condition）的问题，从而导致程序出现不可预期的错误。互斥量可以用来解决这个问题，它可以实现对共享资源的互斥访问，保证同一时刻只有一个线程可以访问共享资源。通俗点说，互斥量就是限制一段代码以读的形式实现。 互斥量可以看作是一个特殊的变量，它有两种状态：锁定（locked）和未锁定（unlocked），只有获得锁的线程才能访问共享资源，其他线程需要等待锁的释放才能继续执行。一个线程可以通过尝试加锁来获得互斥量，如果互斥量当前处于未锁定状态，则该线程可以获得锁并进入临界区；如果互斥量已经被锁定，则该线程会被阻塞等待互斥量的释放。当线程进入临界区时，互斥量被锁定；当线程离开临界区时，互斥量被释放。 基本用法如下： 1.定义互斥量变量 2.初始化互斥量 3.对临界区加锁 4.销毁互斥量 互斥量的另一个重要特性是递归锁，也叫做可重入锁。当一个线程已经获得了互斥量的锁，并在临界区内执行时，如果再次尝试获得该互斥量的锁，则不会被阻塞，而是继续执行。这种情况下，互斥量被称为递归锁，因为同一个线程可以多次获得该锁。 互斥量的初始化动态初始化和静态初始化放在不同环境中使用，如果是凭空定义出来的变量，用静态初始化更简单些，直接使用默认属性就行，如果当前互斥量是位于结构体中的，用动态方式初始化。 对临界区加锁把同一时刻只能一个线程来访问的那部分共享资源称为临界区。在进入临界区前lock，退出临界区后unlock，互斥量锁住的是一段代码，而非仅仅指一个变量、函数之类的。 注：pthread_mutex_lock()是阻塞的，pthread_mutex_trylock()是非阻塞的。 举个栗子前面的add.c程序，如果是20个线程同时只读是ok的，但是如果这段代码同时运行着20份，某个线程在执行读操作时，别的线程在执行写操作，那就可能出错。 上述add.c程序加入互斥量机制后的结果如下： 编译运行结果如下： 条件变量在线程同步中，条件变量是一种用于线程间通信的机制。它是一种同步原语，用于在一个或多个线程等待某个条件的发生时，使其进入阻塞状态，等待其他线程发出条件变量的信号，使其解除阻塞。 条件变量通常与互斥锁结合使用，以实现线程间的同步和互斥。通常，一个或多个线程在等待某个条件的发生时，会先获得互斥锁，然后通过条件变量进入阻塞状态。在其他线程满足条件时，会发送信号给条件变量，然后解除阻塞状态，继续执行。 条件变量本身不是一个锁，它只是一个等待队列，用于线程之间的通信。线程可以在条件变量上等待某个条件的发生，当条件满足时，其他线程可以通过条件变量来通知等待的线程，从而使得等待的线程重新开始执行。 在使用条件变量时，通常需要注意以下几点： 需要先获得互斥锁，然后再使用条件变量。这可以避免多个线程同时访问共享变量，造成数据不一致的问题。 等待条件时，需要在 while 循环中检查条件是否满足，以避免虚假唤醒的问题。 发送信号时，可以使用 signal 或 broadcast 两种方式。signal 只会唤醒一个等待该条件的线程，而 broadcast 则会唤醒所有等待该条件的线程。 通常，使用条件变量需要以下步骤： 1.定义条件变量和互斥量变量 2.初始化条件变量和互斥量 3.在等待条件时使用条件变量和互斥量 4.在条件满足时使用条件变量和互斥量发送信号 5.销毁条件变量和互斥量 需要注意的是，在使用条件变量时，需要避免竞争条件的问题，并且要确保发送信号的线程和等待条件的线程使用的是同一个互斥量。否则，可能会导致死锁或其他错误。 条件变量的初始化 NAME ​ pthread_cond_destroy, pthread_cond_init — destroy and initialize condition variables SYNOPSIS ​ #include &lt;pthread.h&gt; ​ int pthread_cond_destroy(pthread_cond_t *cond); ​ int pthread_cond_init(pthread_cond_t *restrict cond, ​ const pthread_condattr_t *restrict attr); ​ pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER; RETURN VALUE ​ If successful, the pthread_cond_destroy() and pthread_cond_init() functions shall return zero; otherwise, an error number shall be returned to indicate the error. 等待条件 NAME ​ pthread_cond_timedwait, pthread_cond_wait — wait on a condition SYNOPSIS ​ #include &lt;pthread.h&gt; ​ int pthread_cond_timedwait(pthread_cond_t *restrict cond, ​ pthread_mutex_t *restrict mutex, ​ const struct timespec *restrict abstime); ​ int pthread_cond_wait(pthread_cond_t *restrict cond, ​ pthread_mutex_t *restrict mutex); RETURN VALUE Except for [ETIMEDOUT], [ENOTRECOVERABLE], and [EOWNERDEAD], all these error checks shall act as if they were performed immediately at the beginning of processing for the function and shall cause an error return, in effect, prior to modifying the state of the mutex specified by mutex or the condition variable specified by cond. Upon successful completion, a value of zero shall be returned; otherwise, an error number shall be returned to indicate the error. pthread_cond_wait：让当前线程等待在条件变量 cond 上。该函数需要传递两个参数：一个 pthread_cond_t 类型的指针，表示需要等待的条件变量；一个 pthread_mutex_t 类型的指针，表示需要使用的互斥锁。该函数会自动释放互斥锁，并将当前线程置于等待条件的队列中，直到收到信号或被中断为止。【解锁等待】 如果多个线程等待同一个条件变量，当条件变量被 pthread_cond_signal() 唤醒时，只有一个线程会被唤醒；当条件变量被 pthread_cond_broadcast() 唤醒时，所有等待的线程都会被唤醒。此函数返回 0 表示成功，其他值表示出现错误。 发送信号在多线程编程中，线程之间可能需要同步，例如等待某个条件变量（cond）满足才能继续执行。当一个线程发现条件满足时，它可以通过调用 pthread_cond_signal() 或者 pthread_cond_broadcast() ，向正在等待该条件变量的其他线程发送信号。 NAME ​ pthread_cond_broadcast, pthread_cond_signal — broadcast or signal a condition SYNOPSIS ​ #include &lt;pthread.h&gt; ​ int pthread_cond_broadcast(pthread_cond_t *cond); ​ int pthread_cond_signal(pthread_cond_t *cond); DESCRIPTION ​ These functions shall unblock threads blocked on a condition variable. ​ The pthread_cond_broadcast() function shall unblock all threads currently blocked on the specified condition variable cond. ​ The pthread_cond_signal() function shall unblock at least one of the threads that are blocked on the specified condition variable cond (if any threads are blocked on cond). ​ If more than one thread is blocked on a condition variable, the scheduling policy shall determine the order in which threads are unblocked. When each thread unblocked as a result of a pthread_cond_broadcast() or pthread_cond_signal() returns from its call to pthread_cond_wait() or pthread_cond_timedwait(), the thread shall own the mutex with which it called pthread_cond_wait() or pthread_cond_timedwait(). The thread(s) that are unblocked shall contend for the mutex according to the scheduling policy (if applicable), and as if each had called pthread_mutex_lock(). ​ The pthread_cond_broadcast() or pthread_cond_signal() functions may be called by a thread whether or not it currently owns the mutex that threads calling pthread_cond_wait() or pthread_cond_timedwait() have associated with the condition variable during their waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling pthread_cond_broadcast() or pthread_cond_signal(). ​ The pthread_cond_broadcast() and pthread_cond_signal() functions shall have no effect if there are no threads currently blocked on cond. ​ The behavior is undefined if the value specified by the cond argument to pthread_cond_broadcast() or pthread_cond_signal() does not refer to an initialized condition variable. RETURN VALUE ​ If successful, the pthread_cond_broadcast() and pthread_cond_signal() functions shall return zero; otherwise, an error number shall be returned to indicate the error. pthread_cond_signal()是唤醒一个等待，pthread_cond_broadcast()唤醒多个等待。 举个栗子在一个程序中创建四个线程，使之分别向终端输出a,b,c,d，要求能连续的输出abcd字符串。 信号量当资源在一定范围内可以共享时，互斥量就不太好用了。互斥量是以独占的方式来使用。 信号量（Semaphore）是一个同步原语，用于控制多线程或多进程对共享资源的访问。信号量是一个整数值，通常表示共享资源的可用数量。信号量提供了两个基本操作：等待（wait，又称为P操作）和释放（post，又称为V操作）。 等待（wait，P操作）: 当一个线程或进程执行等待操作时，信号量的值减一。如果信号量的值在操作之后为负数，执行等待操作的线程将被阻塞，直到信号量的值变为非负数。 释放（post，V操作）: 当一个线程或进程执行释放操作时，信号量的值加一。如果有其他线程或进程在等待信号量，其中一个被阻塞的线程将被唤醒，并允许继续执行。 信号量可以用于实现多种同步和协调机制，例如： 互斥访问共享资源: 当信号量的初始值设置为1时，它可以用于实现互斥（mutex）。在这种情况下，执行等待操作的线程将获得对共享资源的独占访问，而其他尝试访问该资源的线程将被阻塞，直到释放操作执行。 同步线程或进程: 当信号量的初始值设置为0时，它可以用于同步线程或进程。例如，一个线程可以在完成某个任务后执行释放操作，而另一个线程可以执行等待操作，等待任务完成。这样可以确保第二个线程在第一个线程完成任务之后才开始执行。 限制对共享资源的并发访问: 当信号量的初始值设置为大于1的整数时，它可以用于限制对共享资源的并发访问。这种情况下，信号量的值表示可以同时访问共享资源的线程或进程的最大数量。 信号量在不同的系统和编程语言中有不同的实现。例如，在Unix系统中，信号量可以通过System V IPC或POSIX IPC实现。在C语言中，可以使用POSIX线程库（pthread）提供的信号量函数，如sem_init、sem_wait、sem_post和sem_destroy。 注：下面函数的参数 sem 都是指向已初始化的 sem_t 类型变量的指针 1.int sem_init(sem_t *sem, int pshared, unsigned int value); 函数 sem_init 用于初始化一个信号量。sem 用于存储初始化后的信号量；参数 pshared 决定信号量是用于线程间同步（设置为0）还是进程间同步（设置为非0）；参数 value 是信号量的初始值。 成功时，函数返回 0；失败时返回 -1，并设置 errno。 2.int sem_destroy(sem_t *sem); 函数 sem_destroy 用于销毁一个信号量，释放其相关资源。 成功时，函数返回 0；失败时返回 -1，并设置 errno。 3.int sem_wait(sem_t *sem); 函数 sem_wait 用于以原子操作的方式减少信号量的值。如果信号量的值大于 0，它将减少信号量的值并立即返回。如果信号量的值为 0，则调用线程将阻塞，直到信号量的值变为正数。 成功时，函数返回 0；失败时返回 -1，并设置 errno。 4.int sem_post(sem_t *sem); 函数 sem_post 用于以原子操作的方式增加信号量的值。如果有其他线程因为 sem_wait 被阻塞在该信号量上，它们将被唤醒。 成功时，函数返回 0；失败时返回 -1，并设置 errno。 sem_init(3) NAME ​ sem_init - initialize an unnamed semaphore SYNOPSIS ​ #include &lt;semaphore.h&gt; ​ int sem_init(sem_t *sem, int pshared, unsigned int value); ​ Link with -pthread. DESCRIPTION ​ sem_init() initializes the unnamed semaphore at the address pointed to by sem. The value argument specifies the initial value for the semaphore. ​ The pshared argument indicates whether this semaphore is to be shared between the threads of a process, or between processes. ​ If pshared has the value 0, then the semaphore is shared between the threads of a process, and should be located at some address that is visible to all threads (e.g., a global variable, or a variable allocated dynamically on the heap). ​ If pshared is nonzero, then the semaphore is shared between processes, and should be located in a region of shared memory (see shm_open(3), mmap(2), and shmget(2)). (Since a child created by fork(2) inherits its parent’s memory mappings, it can also access the semaphore.) Any process that can access the shared memory region can operate on the semaphore using sem_post(3), sem_wait(3), and so on. ​ Initializing a semaphore that has already been initialized results in undefined behavior. RETURN VALUE ​ sem_init() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error. sem_destroy(3) NAME ​ sem_destroy - destroy an unnamed semaphore SYNOPSIS ​ #include &lt;semaphore.h&gt; ​ int sem_destroy(sem_t *sem); ​ Link with -pthread. DESCRIPTION ​ sem_destroy() destroys the unnamed semaphore at the address pointed to by sem. ​ Only a semaphore that has been initialized by sem_init(3) should be destroyed using sem_destroy(). ​ Destroying a semaphore that other processes or threads are currently blocked on (in sem_wait(3)) produces undefined behavior. ​ Using a semaphore that has been destroyed produces undefined results, until the semaphore has been reinitialized using sem_init(3). RETURN VALUE ​ sem_destroy() returns 0 on success; on error, -1 is returned, and errno is set to indicate the error. ERRORS ​ EINVAL sem is not a valid semaphore. sem_wait(3) NAME ​ sem_wait, sem_timedwait, sem_trywait - lock a semaphore SYNOPSIS ​ #include &lt;semaphore.h&gt; ​ int sem_wait(sem_t *sem); ​ int sem_trywait(sem_t *sem); ​ int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); ​ Link with -pthread. DESCRIPTION ​ sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore’s value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call. ​ sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking. ​ sem_timedwait() is the same as sem_wait(), except that abs_timeout specifies a limit on the amount of time that the call should block if the decrement cannot be immediately performed. The abs_timeout argument points to a structure that specifies an absolute timeout in seconds and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC). This structure is defined as follows: ​ struct timespec { ​ time_t tv_sec; &#x2F;* Seconds *&#x2F; ​ long tv_nsec; &#x2F;* Nanoseconds [0 .. 999999999] *&#x2F; ​ }; ​ If the timeout has already expired by the time of the call, and the semaphore could not be locked immediately, then sem_timedwait() fails with a timeout error (errno set to ETIMEDOUT). ​ If the operation can be performed immediately, then sem_timedwait() never fails with a timeout error, regardless of the value of abs_timeout. Furthermore, the validity of abs_timeout is not checked in this case. RETURN VALUE ​ All of these functions return 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error. sem_post(3) NAME ​ sem_post - unlock a semaphore SYNOPSIS ​ #include &lt;semaphore.h&gt; ​ int sem_post(sem_t *sem); ​ Link with -pthread. DESCRIPTION ​ sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore’s value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore. 释放信号量，将信号量的值加 1. RETURN VALUE ​ sem_post() returns 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error. 举个栗子【互斥量+条件变量 -&gt; 单个信号量】使用互斥量+条件变量完成一个可以记次数（有资源上限）的资源共享。使用信号量机制重构之前的计算质数的程序（primer.c）： 运行.&#x2F;mysem程序后，通过ps ax -L指令可看到类似于如下内容： 反复执行，5021进程一直在，后面的4个线程会变。 后面介绍进程间通信时，会介绍信号量数组，相当于这个模型的放大，如果把信号量存在数组或指针当中，就成了mytb或anytimer的一个实现套路。封装的mytb库是解决问题常用的一个框架。 补充：在vim中使用快捷键进行字符串替换操作，将全文中的mytbf字符串都替换为mysem。 :%s&#x2F;mytbf&#x2F;mysem&#x2F;g 将每一行中的所有mytbf替换为mysem :%s&#x2F;mytbf&#x2F;mysem 将每一行中的第一个mytbf替换为mysem :s&#x2F;mytbf&#x2F;mysem&#x2F;g 将当前行中的所有mytbf替换为mysem 互斥量 VS 条件变量 VS 信号量互斥量（Mutex）、条件变量（Condition Variable）和信号量（Semaphore）是用于同步和协调多线程或多进程之间的执行的常见工具。它们之间的主要区别如下： 互斥量（Mutex）: 互斥量主要用于保护共享资源的访问，确保同一时刻只有一个线程或进程可以访问共享资源。互斥量的基本操作包括加锁（lock）和解锁（unlock）。当一个线程获取互斥量时，其他线程必须等待直到互斥量被释放。互斥量通常用于实现临界区，即一段只能被一个线程执行的代码。 条件变量（Condition Variable）: 条件变量用于线程间的同步，它允许一个或多个线程等待满足某个条件。条件变量通常与互斥量一起使用，当一个线程需要等待某个条件时，它会解锁互斥量并阻塞在条件变量上，当条件满足时，另一个线程可以使用条件变量通知等待的线程，此时，被唤醒的线程会重新获取互斥量并继续执行。条件变量的主要操作有：等待（wait）、通知一个（signal）和通知所有（broadcast）。 信号量（Semaphore）: 信号量是一个计数器，用于控制对共享资源的访问。信号量有两个基本操作：等待（wait，又称为P操作）和释放（post，又称为V操作）。当一个线程执行等待操作时，信号量的值减一，如果此时信号量的值小于零，线程会阻塞。当一个线程执行释放操作时，信号量的值加一，如果有其他线程在等待该信号量，其中一个线程将被唤醒。信号量可以用于实现互斥（当信号量的初始值为1时）和同步（当信号量的初始值为0时）。 总结： 互斥量主要用于保护共享资源，确保同一时刻只有一个线程可以访问该资源。 条件变量用于线程间同步，允许线程等待某个条件满足。 信号量用于控制对共享资源的访问，可实现互斥和同步。 互斥量和条件变量通常用于多线程编程，而信号量可以用于多线程和多进程编程。在某些系统中，信号量实现可能基于互斥量和条件变量。"},{"title":"第一章：输入输出","date":"2023-07-27T10:36:59.000Z","url":"/2023/07/27/Chapter1_IO/","tags":[["system programming","/tags/system-programming/"]],"categories":[["《系统编程实践（C语言版）》","/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/"]],"content":"主要介绍（1）I&#x2F;O相关函数；（2）文件描述符 注：标题中显示的函数数字表示该函数在man手册中所在章节（第2章的是系统调用函数，第3章的是标准函数） I&#x2F;O是一切实现的基础。 标准I&#x2F;Ofopen(3)fopen()函数用于打开一个文件，并返回一个指向FILE结构体的指针，该结构体包含了关于文件的信息，如文件流、读写位置等，以供后续使用高级文件流进行文件的读写操作。它可以用于创建新文件、打开已存在的文件，并指定文件的打开模式（只读、只写、追加等）。函数原型如下： 参数说明： path：要打开的文件路径的字符串，可以是绝对路径或相对路径。 mode：一个字符串，用来指定文件打开的模式和选项。模式字符串中的字符代表不同的选项，例如”r”表示只读模式，”w”表示只写模式，”a”表示追加模式等。详细的模式选项见下面的说明。 文件打开模式说明： “r“: 只读模式。文件必须存在，否则打开失败。 “r+“: 读写模式。文件必须存在，可以读取和写入。 “w“: 只写模式。如果文件不存在，则创建新文件；如果文件存在，则清空文件内容。 “w+“: 读写模式。如果文件不存在，则创建新文件；如果文件存在，则清空文件内容，可以读取和写入。 “a“: 追加模式。如果文件不存在，则创建新文件；如果文件存在，则在文件末尾追加写入。 “a+“: 读写模式。如果文件不存在，则创建新文件；如果文件存在，则在文件末尾追加读写。 函数返回值： 执行成功时，返回一个指向FILE结构体的指针，指向打开的文件流。如果打开或创建文件成功，该指针非空； 如果打开或创建文件失败，返回值为NULL，表示文件打开失败或者权限不足。 The argument mode points to a string beginning with one of the following sequences (possibly followed by additional characters, as described below): ​ r: Open text file for reading. The stream is positioned at the beginning of the file. ​ r+: Open for reading and writing. The stream is positioned at the beginning of the file. ​ w: Truncate file to zero length or create text file for writing. The stream is positioned at the beginning of the file. ​ w+: Open for reading and writing. The file is created if it does not exist, otherwise it is truncated. The stream is positioned at the beginning of the file. ​ a: Open for appending (writing at end of file). The file is created if it does not exist. The stream is positioned at the end of the file. ​ a+: Open for reading and appending (writing at end of file). The file is created if it does not exist. The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file. beginning of the file：文件打开后第一个有效字节的位置； end of file：文件的最后一个有效字节的下一个位置； 当前位置：读和写都发生在文件的当前位置； 注意事项： （1）fp &#x3D; fopen(“tmp”,”readwrite”)语句中的mode变量效果等价于”r”，“r+write”等价于”r+”。 （2）在调用fopen()函数时，需要确保提供合适的文件打开模式，以防止意外地覆盖或清空原有文件内容。 （3）对于fopen()函数返回的文件指针，在进行文件读写操作后，需要调用fclose()函数来关闭文件流，释放相关资源。 文件I&#x2F;O文件描述符通俗点说，文件描述符就是数组下标，一个整型数。 每个文件都有一个唯一标识inode（就像每个人都有个唯一的身份证号），如果使用open()打开一个文件，会获得一个相关联的结构体，这个结构体中包含了操作该文件时所有必要的信息，就像fopen()打开一个文件会返回一个FILE指针，通过这个指针来进行文件的读写，前面获得的结构体也会有个指针，该指针存放在数组中，交给用户的是存放这个指针的数组的下标，即一个整型数。通过这个整型数找到一个指针，通过这个指针找到一个结构体，通过这个结构体可以操作一个文件。 这个数组有多大？一个进程最多能打开多少个文件，通过ulimit来查看。 一说到stream，其中三个标准的是stdin，stdout，stderr，一说到fd，其中三个标准的是0,1,2。 文件描述符优先使用当前可用范围内最小的。 如果把下标4的内容复制一份放到下标为6的位置，则下标4和下标6对应的两个指针关联的是同一个结构体，如果close(4)，那6那部分还能用吗？如果关联的结构体释放掉了，那下标6的指针就会成为一个野指针。每个结构体当中应该有个计数器，来反映当前结构体被几个指针引用了，如果这个计数器的值不是0，就不free()掉。 open(2)open()函数用于打开一个已存在的文件或者创建一个新文件，函数原型如下： 参数说明： pathname：要打开的文件所在路径的字符串，可以是绝对路径或相对路径。 flags：位图，用来指定文件打开的模式和选项，必须包含以下中的一个：O_RDONLY，O_WRONLY，O_RDWR。如果flags中有O_CREAT，用三参形式的open()，没有的话，就用两参形式的open()。 mode：创建新文件时，该参数用来指定新文件的权限，它是一个八进制数，通常使用 0644 这样的形式。 返回值： 返回一个整型的文件描述符（File Descriptor），代表打开或创建的文件。 如果打开或创建文件成功，将返回非负整数的文件描述符； 如果出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 注意事项： 打开文件成功后，务必在不需要使用文件描述符时及时关闭文件，以防止文件描述符泄漏。 使用open()函数创建文件时，应该在flags中使用O_CREAT选项，并且提供合适的文件权限模式mode，以确保创建的文件具有正确的权限。 在对文件进行读写操作时，建议进行错误检查和适当的错误处理，以应对可能发生的错误情况。 close(2)close()函数用于关闭已打开的文件，释放与之关联的系统资源。函数原型如下： 参数说明： fd：表示要关闭的文件描述符。它是open()，socket()等函数返回的一个整型值。 函数返回值： 执行成功时，返回值为0； 如果出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 read(2)read()函数用于从已打开的文件描述符中读取数据，并将读取的内容存储到指定的缓冲区中。函数原型如下： 参数说明： fd：表示要读取的文件描述符（File Descriptor）。 buf：是一个指向用于存储读取数据的缓冲区的指针。读取的数据将被存储到这个缓冲区中。 count：表示要读取的字节数，即希望从文件中读取的数据量。 函数返回值： read()函数执行成功时，返回实际读取的字节数；（这个值可能小于等于count，因为在某些情况下，可能读取到文件末尾或者发生了错误） 若已到达文件末尾，返回值为0； 若出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 On success, the number of bytes read is returned (zero indicates end of file), and the file position is advanced by this number. It is not an error if this number is smaller than the number of bytes requested; this may happen for example because fewer bytes are actually available right now (maybe because we were close to end-of-file, or because we are reading from a pipe, or from a terminal), or because read() was interrupted by a signal. See also NOTES.On error, -1 is returned, and errno is set appropriately. In this case, it is left unspecified whether the file position (if any) changes.返回值：读到的字节数；若已到达文件尾端，返回0；若出错，返回-1。 注意事项： read()函数是一个阻塞调用，如果没有数据可读，程序会阻塞在该函数处等待数据到达或者出现其他特定的事件。 使用read()函数读取文本文件时，注意文本文件中可能含有换行符\\n，所以在打印输出时可能会换行。如果不需要换行，可以在输出中去掉换行符。 write(2)write()函数用于将数据写入已打开的文件描述符中，将指定的缓冲区数据写入到文件中。函数原型如下： 参数说明： fd：表示要写入的文件描述符。 buf：是一个指向要写入数据的缓冲区的指针。这个缓冲区中的数据将被写入到文件中。 count：表示要写入的字节数，即缓冲区中要写入到文件的数据量。 函数返回值： write()函数执行成功时，返回实际写入的字节数。这个值通常等于count，除非写入遇到错误或遇到了输出限制。 若返回值为-1，表示写入发生错误，并设置全局变量errno来表示具体的错误类型。 On success, the number of bytes written is returned (zero indicates nothing was written). It is not an error if this number is smaller than the number of bytes requested; this may happen for example because the disk device was filled. See also NOTES.On error, -1 is returned, and errno is set appropriately.If count is zero and fd refers to a regular file, then write() may return a failure status if one of the errors below is detected. If no errors are detected, or error detection is not performed, 0 will be returned without causing any other effect. If count is zero and fd refers to a file other than a regular file, the results are not specified.返回值：若成功，返回已写的字节数；若出错，返回-1。 注意事项： write()函数是一个阻塞调用，如果写入操作被阻塞（例如写入缓冲区已满），程序会等待直到能够继续写入或出现其他特定的事件。 当写入数据到文件时，注意文件权限和文件打开模式，确保文件能够正确写入。如果文件权限不足或文件未正确打开，写入操作可能会失败。 lseek(2)lseek()函数用于设置文件的偏移量。程序可以在文件中定位到指定的位置，从而实现对文件的随机访问。函数原型如下： 参数说明： fd：表示要进行偏移设置的文件描述符。 offset：表示要设置的偏移量。它是一个off_t类型的值，可以是正数、负数或零，用于指定相对于whence参数所指定位置的偏移量。 whence：表示偏移量的参考位置，即偏移量的计算方式。它可以取三个值： SEEK_SET：从文件起始位置开始计算偏移量。此时，offset表示从文件起始位置开始的偏移量。 SEEK_CUR：从当前文件读写位置开始计算偏移量。此时，offset表示相对于当前位置的偏移量。 SEEK_END：从文件末尾开始计算偏移量。此时，offset表示相对于文件末尾的偏移量。 函数返回值： 函数执行成功时，返回设置后的文件偏移量。 若设置成功，返回新的文件偏移量，该值通常等于offset参数； 若出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 The lseek() function allows the file offset to be set beyond the end of the file (but this does not change the size of the file). If data is later written at this point, subsequent reads of the data in the gap (a “hole”) return null bytes (‘\\0’) until data is actually written into the gap. Upon successful completion, lseek() returns the resulting offset location as measured in bytes from the beginning of the file. On error, the value (off_t) -1 is returned and errno is set to indicate the error.返回值：若成功，返回新的文件偏移量；若出错，返回-1。 注：off_t类型用于指示文件的偏移量，常就是long类型，其默认为一个32位的整数，在gcc编译中会被编译为long int类型，在64位的Linux系统中则会被编译为long long int，这是一个64位的整数，其定义在unistd.h头文件中可以查看。 注意事项： 对于不支持偏移设置的设备或文件（如终端、管道等），lseek()函数可能不起作用，返回值为-1，并设置errno为ESPIPE错误。"},{"title":"安装破解新版BurpSuite","date":"2021-07-19T12:43:59.000Z","url":"/2021/07/19/%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3%E6%96%B0%E7%89%88BurpSuite/","tags":[["BurpSuite","/tags/BurpSuite/"]],"categories":[["软件激活","/categories/%E8%BD%AF%E4%BB%B6%E6%BF%80%E6%B4%BB/"]],"content":"新发布的BurpSuite界面看着更舒适，也增加了一些新功能，下面记录的是BurpSuite 2020.12专业版的安装过程。（实测2021.7也可以用同样方式安装激活） 注：jdk 8环境下会出现闪退现象，jdk 16环境下会出现如下图所示问题： 建议安装jdk 11。原有Java版本卸载可参考如下：  版本11之后的jdk如下图所示没有jre文件，可以通过如下方式生成： 通过管理员权限运行cmd命令之后，进入jdk的安装目录，然后执行以下指令： 接下来配置环境变量， Jdk 11安装成功之后，运行安装包里的run.bat文件，结果如下： License key可通过License KeyGen.jar文件生成。点击运行License KeyGen.jar结果如下： 将上图红框中的字符串复制粘贴，之后点击“Next” 接着点击如下图中的“Manual activation”， 将自动生成的Activation Response复制粘贴即可： 可以看到BurpSuite的有效期至2091年，近乎永久有效。 注：关闭BurpSuite软件后，下次要使用时直接点击运行run.bat文件即可"},{"title":"floor报错注入原理分析","date":"2021-07-15T02:56:08.000Z","url":"/2021/07/15/floor%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"引子​ 最近工作中遇到了floor报错注入的相关知识，网上找到的文章有蛮多写得都不错，从原理到一些细节讲得都很到位，把它们总结归纳一下，于是就有了这篇文章。 报错的条件​ floor报错注入是指利用 select count(*) from table group by floor(rand(0)*2) 构造特定的语句导致数据库查询错误，从而实现在报错信息中显示攻击者希望看到的数据。其它语句，例如select count(*),(floor(rand(0)*2))x from table group by x;可以看做是它的变形。 ​ 在上面的情况下它报错了，但是不是任何情况下都会导致报错呢？ ​ 我们先来试试books表中只有一条记录的情况下，该语句会不会报错？多次执行结果均如下图所示： ​ 没有报错，再增加一条语句试试看，多次执行的结果均是如下图所示： ​ 没有报错，继续增加一条记录，当表中有三条记录时，看看结果如何？多次执行结果均是如下图所示： ​ 成功报错，而且不管你执行多少次，结果都是一样的。由此可见，select count(*) from table group by floor(rand(0)*2) 语句报错是有条件的，记录必须至少有3条，那问题来啦，原理何在呢？继续往下看。 随机因子起作用么？​ 来看看报错原因与随机因子的联系，把随机因子去掉，再按照上面的过程试一遍。先看一条记录的情况，多次执行结果均如下图所示： ​ 没有报错，再增加一条语句试试看，多次执行的结果如下图所示： ​ 两条记录的情况下，结果就变得不确定了，可能报错，也可能不报错。三条记录的情况与两条记录一样，结果也是不确定的。 ​ 由此可见，报不报错和随机因子是有关联的，但是有什么关联呢？为什么直接使用rand()，有两条记录的情况下就会报错，而且是有时候报错，有时候不报错，而rand(0)的时候在两条的时候不报错，在三条以上就绝对报错？我们继续往下看。 group by与count(*)​ group by主要用来对数据进行分组，相同的分为一组，常与count()结合使用。在此，我们需要明白分组计数的过程中发生了什么。这个过程中会建立一个有两个字段的虚拟表，一个是分组的 key ，一个是计数值 count(*)。在查询数据的时候，首先查看该虚拟表中是否存在该分组，如果存在那么计数值加1，不存在则新建该分组。 floor(rand(0)*2)MySQL官网上这样写着： The RAND() function in MySQL is used to a return random floating-point value V in the range 0 &lt;&#x3D; V &lt; 1.0. Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. ​ MySQL官方所说到的“be evaluated multiple times”就是说使用group by的时，查询过程中floor(rand(0)*2)会被执行一次，如果虚表不存在记录，插入虚表的时候会再被执行一次。 Wooyun知识库里T-Safe团队这样写着： RAND() in a WHERE clause is re-evaluated every time the WHERE is executed. You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times. ​ rand()可以产生一个[0,1)之间的随机数，当提供一个参数因子0后，rand(0)每次产生的“随机数”都是确定的。 ​ floor()返回小于等于该值的最大整数，rand()*2返回的是[0,2)之间的随机数，再配合floor()就可以产生两个确定的数，即0和1。floor(rand(0)*2)会产生一个确定的01序列（以下内容来源于一个拥有7条记录的表）：0110110…… 报错分析floor(rand(0)*2)报错​ group by 进行分组时，floor(rand(0)*2)执行一次（查看分组是否存在），如果虚拟表中不存在该分组，那么在插入新分组的时候 floor(rand(0)*2) 就又计算了一次。下面来具体看看select count(*) from table group by floor(rand(0)*2) 的查询过程： （1）查询前默认会建立如下空虚拟表： （2）取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算)，查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕，结果如下： （3）查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕，结果如下： （4）查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 （5）整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 floor(rand()*2)报错​ 在没加入随机因子的情况下，floor(rand()*2)是不可测的，因此可能报错，也可能不报错。在两条记录的情况下，只要出现如下情况，即可报错： ​ 最重要的是前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()*2)不会再被计算做为虚表的键值，这也就是为什么不加随机因子有时候会报错，有时候不会报错的原因。 ​ 当前面记录让虚表长成如下图这样子后，由于不管查询多少条记录，floor(rand()*2)的值在虚表中都能找到，所以不会被再次计算，只是简单的增加count(*)字段的数量，所以不会报错，比如floor(rand(1)*2)： ​ 在前两条记录查询后，虚拟表已经存在0和1两个键值了，所以后面再怎么弄还是不会报错。总之报错需要count(*)，rand()、group by，三者缺一不可。 ​ floor(rand(0)*2的作用就是产生预知的数字序列0110110...，然后再利用 rand() 的特殊性和group by的虚拟表，最终引起了报错。 利用方式​ floor报错注入的原因是group by在向临时表插入数据时，由于rand()多次计算导致插入临时表时主键重复，从而报错，又因为报错前concat()中的SQL语句或函数被执行，所以该语句报错且被抛出的主键是SQL语句或函数执行后的结果。 ​ floor报错注入的利用，通俗点说就是利用concat()构造特殊的主键，当主键值不唯一时就报错并回显该主键值，主键值中就包含着我们想要的内容。下面以本地搭建的实验环境为例，介绍相关利用方式。 爆库 ​ 由于 and 后要跟1或者0，所以构造sql语句select 1 。 爆表 爆列 爆字段 总结​ 在写这篇文章的过程中，理解了floor函数报错的条件，报错的原理以及利用方式。总的来说，还是深感专业技能的不足，还需要加强学习。 参考资料Mysql报错注入原理分析(count()、rand()、group by) mysql的floor()报错注入方法详细分析"},{"title":"CentOS 7配置SSH免密登录","date":"2021-07-14T11:49:50.000Z","url":"/2021/07/14/CentOS%207%E9%85%8D%E7%BD%AESSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/","tags":[["SSH免密登录","/tags/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"]],"categories":[["undefined",""]],"content":"先在CentOS 7中配置固定IP地址，然后实现两台主机之间相互SSH免密登录。 CentOS 7 配置固定IPCentOS 7系统配置固定IP地址（192.168.111.135）的四个步骤如下： （1）配置虚拟机NAT模式的地址参数 （2）配置本机VMnet8地址参数 （3）修改CentOS 7固定IP的配置文件 （4）重启网络服务 （5）验证结果 配置SSH免密登录（1）生成密钥对 CentOS 7默认使用RSA加密算法生成密钥对，保存在~&#x2F;.ssh目录下为id_rsa（私钥）和id_rsa.pub（公钥），密钥对生成过程中会提示输入私钥加密密码，直接回车就行。 （2）移动id_rsa.pub文件 以同样的方式在192-168-111-135中生成相应密钥对，然后将192-168-111-134的公钥移动到192-168-111-135的&#x2F;root&#x2F;.ssh文件夹下： （3）验证免密登录 上面结果表明，192-168-111-134机器成功通过SSH免密登录了192-168-111-135机器，配置成功。后面配置192-168-111-135免密登录192-168-111-134情况类似。"},{"title":"DC靶机","date":"2019-09-05T18:25:31.000Z","url":"/2019/09/06/DC%E9%9D%B6%E6%9C%BA/","categories":[["渗透测试","/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"]],"content":"前言将近一年没玩Web，没玩渗透了，企业来学校培训教了点Web安全的姿势(不教二进制，有点失望！！！后来问了下，原来是半路出家的，不会 (滑稽 )，教的时候，是用DC靶机中的DC-4，做完实验后，干脆写个博客算了，就当是玩玩，慢慢地也会把其它几个补全来。下载地址 正菜前的甜点1）安装DC-4靶机：直接用VMware打开DC-4.ova文件，导入到相应文件夹即可； 2）将Kali与靶机设置为同一网段：VMware–虚拟机–设置–网络适配器–仅主机模式 3）获取目标主机的IP地址：首先获取Kali的IP地址为192.168.208.129，再寻找同网段内的其他主机的IP地址，一个个排除，直到找到目标主机的地址为192.168.208.131 正菜在浏览器中访问该地址后，发现一个登入框： 使用burp爆破，用Kali自带的两个字典中较小的那一个即可【Kali中自带了两个字典，一大一小为别为：&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz；&#x2F;usr&#x2F;share&#x2F;john&#x2F;password.lst】，发现用户名为admin，密码为happy，登入后结果如下： 可以看到能够执行ls -l, du -h,df -h这三个命令，猜测可能存在命令注入漏洞，修改radio参数，可以看到有三个用户名 ，及各用户名下的相应文件，其中有个/home/jim/backups/old-passwords.bak文件，通过cat命令可以获得其内容： 考虑到目标主机还开启了22端口，也许是要我们使用ssh登入，因此，使用hydra爆破，将charles，jim，sam写入用户名字典user.txt中，将old-passwords.bak中的内容作为密码字典old-password.txt，爆破结果如下： 可以发现jim的ssh登入密码为：jibril04。使用该密码登入：ssh jim@192.168.208.131，登入后打印mbox文件 给人的第一印象就是，这是封邮件，因此，我们转到/var/mail目录下，发现也有个jim文件，打印结果为： 将用户从jim切换为charles，还发现charles貌似权限不够 查看用户权限，发现该用户可以以root权限免密码执行 /usr/bin/teehee 提权时，我们可以选择用定时器提权，或者是篡改 passwd写入一个具有root权限的伪用户进行get root 选择添加一个f1yingf0x用户，并使用teehee执行写入 passwd中（也可以选择通过teehee的sudo提升权限以root身份写入crontab计划任务通过执行获取root权限） 获得root权限后，打印root目录下的flag.txt文件，获得最终的结果： 参考资料DC-4渗透实战"},{"title":"深入理解GOT表覆写技术","date":"2019-09-05T15:01:04.000Z","url":"/2019/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E8%A6%86%E5%86%99%E6%8A%80%E6%9C%AF/","tags":[["ELF","/tags/ELF/"],["共享库","/tags/%E5%85%B1%E4%BA%AB%E5%BA%93/"],["动态链接","/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"]],"categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"前言玩pwn的时候，有时要用到got表覆写技术，本文在于分享对GOT表覆写技术的理解，铺垫性的基础知识较多，目的在于让初学者知其然，还要知其所以然！ ELF文件生成过程 注：gcc命令实际上是具体程序（如ccp、cc1、as等）的包装命令，用户通过gcc命令来使用具体的预处理程序ccp、编译程序cc1和汇编程序as等。 预处理过程主要处理源文件中以“#”开头的预编译指令，经过预编译处理后，得到的是预处理文件（如，hello.i) ，它还是一个可读的文本文件 。 编译过程将预处理后得到的预处理文件（如 hello.i）进行词法分析、语法分析、语义分析、优化后，生成汇编代码文件。经过编译后，得到的汇编代码文件（如 hello.s）还是可读的文本文件，CPU无法理解和执行它。 汇编过程汇编程序（汇编器）用来将汇编语言源程序转换为机器指令序列（机器语言程序）。汇编结果是一个可重定位目标文件（如 hello.o），其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容。 预处理、编译和汇编三个过程针对一个模块（一个*.c文件）进行处理，得到对应的一个可重定位目标文件（一个*.o文件）。 链接过程将多个可重定位目标文件合并以生成可执行目标文件 目标文件格式概述三类目标文件1、可重定位目标文件 (Relocatable File; 后缀名为“.o”) 2、可执行目标文件(Executable File；一般没有后缀名) 3、共享的目标文件 (Shared Object File；后缀名为“.so”) 标准的几种目标文件格式 DOS操作系统（最简单） ：COM格式，文件中仅包含代码和数据，且被加载到固定位置； System V UNIX早期版本：COFF格式，文件中不仅包含代码和数据，还包含重定位信息、调试信息、符号表等其他信息，由一组严格定义的数据结构序列组成； Windows： PE格式（COFF的变种），称为可移植可执行(Portable Executable，简称PE)；4)Linux等类UNIX：ELF格式（COFF的变种），称为可执行可链接(Executable and Linkable Format，简称ELF)； 两种视图链接视图（被链接）：可重定位目标文件(Relocatable object files) 执行视图（被执行）：可执行目标文件（Executable object files） ELF可重定位目标文件 .bss 节 ELF可执行目标文件 符号及符号表链接操作的步骤 Step 1. 符号解析（Symbol resolution） Step 2. 重定位 链接符号的类型每个可重定位目标模块m都有一个符号表，它包含了在m中定义和引用的符号。有三种链接器符号： 目标文件中的符号表 静态链接和符号解析静态链接对象多个可重定位目标模块 + 静态库（标准库、自定义库）（.o文件） （.a文件，其中包含多个.o模块）静态库 (.a archive files) 自定义一个静态库文件 链接器中符号解析的全过程三个重要集合：E 将要被合并以组成可执行文件的所有目标文件集合U 当前所有未解析的引用符号的集合D 当前所有定义符号的集合 开始E、U、D为空，首先扫描main.o，把它加入E，同时把Function加入U，main加入D。接着扫描到mylib.a，将U中所有符号(本例中为Function)与mylib.a中所有目标模块(program1.o和program2.o)依次匹配，发现在program1.o中定义了Function，故program1.o加入E，Function从U转移到D。在program1.o中发现还有未解析符号printf，将其加到U。不断在mylib.a的各模块上进行迭代以匹配U中的符号，直到U、D都不再变化。此时U中只有一个未解析符号printf，而D中有main和Function。因为模块program2.o没有被加入E中，因而它被丢弃。接着，扫描默认的库文件libc.a，发现其目标模块printf.o定义了printf，于是printf也从U移到D，并将printf.o加入E，同时把它定义的所有符号加入D，而所有未解析符号加入U。处理完libc.a时，U一定是空的。 注:被链接模块应按调用顺序指定！若命令为： 首先，扫描mylib，因是静态库，应根据其中是否存在U中未解析符号对应的定义符号来确定哪个.o被加入E。因为开始U为空，故其中两个.o模块都不被加入E中而被丢弃。然后，扫描main.o，将Function加入U，直到最后它都不能被解析,因此，出现链接错误，因为它只能用mylib.a中符号来解析，而mylib中两个.o模块都已被丢弃！ 可执行文件的加载通过调用execve系统调用函数来调用加载器： execve()函数的用法如下： filename是加载并运行的可执行文件名(如./hello)，可带参数列表argv和环境变量列表envp。若错误（如找不到指定文件filename），则返回-1，并将控制权交给调用程序； 若函数执行成功，则不返回，最终将控制权传递到可执行目标中的主函数main。 主函数main()的原型形式如下： argc指定参数个数，参数列表中第一个总是命令名（可执行文件名） hello程序的加载和运行过程 共享库和动态链接【划重点】静态库有一些缺点 解决方案: Shared Libraries （共享库） 自定义一个动态共享库文件 地址无关代码【划重点】• 动态链接用到一个重要概念：我们希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就叫做**地址无关代码（Position-Independent Code，PIC)**。 • 共享库代码是一种PIC • 所有引用情况 要实现动态链接，必须生成PIC代码，要生成PIC代码，主要解决第3和第4这两个问题 （1）模块内的函数调用或跳转 调用或跳转源与目的地都在同一个模块，相对位置固定，只要用相对偏移寻址即可。call的目标地址为：0x8048369 + 0xffffffdb(-0x25) &#x3D; 0x8048344注： 该指令是一条近址相对位移调用指令（2）模块内的数据引用 注：任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，那么只要相对于当前指令加上固定的偏移量就可以访问模块内部的数据了。 变量a与引用a的指令之间的距离为常数，调用__get_pc后，call指令的返回地址被置ECX。若模块被加载到0x9000000，则a的访问地址为：0x9000000+0x34c+0x118c(指令与.data间距离)+0x28(a在.data节中偏移) （3）模块间的数据访问ELF解决模块间的数据访问目标地址的做法是在数据段里面建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table,Got）,当代码需要引用该全局变量时，可通过GOT中相对应的项间接引用。模块在编译时可以确定GOT相对于当前指令的偏移，然后根据变量地址在GOT中的偏移就可得到变量的地址。比如，当指令要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。 （4）模块间的调用、跳转同理，我们可以使用类似于模块间的数据访问的方式，在GOT中加一个项(指针)，用于指向目标函数的首地址（如&amp;ext），但是也要多用三条指令并额外多用一个寄存器（如EBX）。因此，可用“延迟绑定（lazy binding）”技术来优化动态链接性能：当函数第一次被用到时才进行绑定（符号查找、重定位等），这样可以大大加快程序启动速度。ELF使用PLT（Procedure linkage Table, 过程链接表)的方法来实现。通常我们调用某个外部模块的函数时，应该是通过GOT中相应的项进行间接跳转。而PLT为了实现延迟绑定，在这个过程中有增加了一层间接跳转。调用函数并不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项，比如bar()在PLT中的项的地址我们称为bar@plt。其中bar@plt的实现如下： 第一条指令是通过一条GOT间接跳转的指令。bar@GOT表示GOT中保存的bar()这个函数相应的项。链接器在初始化阶段没有将bar()的地址填入到该项中，而是将上面代码中第二条指令“push n”的地址填入到bar@GOT中。显然，第一条指令的效果是跳转到第二条指令，第二条指令将一个数字n压入堆栈中，该数字为bar这个符号引用在重定位表“.rel.plt”中的下标。接着将模块的ID压入堆栈中，然后调用_dl_runtime_resolve函数来完成符号解析和重定位工作。_dl_runtime_resolve在进行一系列工作以后将bar()的真正地址填入到bar@GOT中。再次调用bar@plt时，第一条jump指令能跳转到真正的bar()函数中，bar()函数返回的时候会根据堆栈里保存的EIP直接返回到调用者，而不会在继续执行bar@plt中第二条指令开始的那段代码。ELF将GOT拆分为两个表叫做“.got”和“.got.plt”: 注：Linux下，ELF可执行文件虚拟地址空间默认从地址0x08048000开始分配 实践部分理解了何为GOT表和PLT之后，我们再通过pwnable.kr中的题目passcode来介绍一下GOT表覆盖技术： 解题思路:由于welcome()和login()函数调用栈的EBP相同，通过gdb调试后可以发现 输入的变量没有用取地址符号&amp;，导致读入数据的时候，scanf会把这个变量中的值当成存储地址来存放数据，name值的最后4个字节是passcode1值，所以可以通过将passcode1的值改为fflush()的地址，scanf()之后会调用fflush()函数，覆盖fflush()在GOT表中的内容，把system(“/bin/cat flag”)对应汇编代码地址写入fflush()中，当这个函数被调用时，就会直接执行system(“/bin/cat flag”)。 通过objdump -R passcode命令查看GOT表可以发现fflush()位于0x0804a004处，即将0x80485e3（调用system的地址）覆写位于0x0804a004的fflush()函数的GOT表。 参考资料《程序员的自我修养》《计算机系统基础(一)：程序的表示、转换与链接》 注：本文首发于安全客 "},{"title":"write函数","date":"2019-08-26T12:52:54.000Z","url":"/2019/08/26/write%E5%87%BD%E6%95%B0/","categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"下面介绍下write这个普遍用来泄漏信息的函数： write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。如果顺利，write()会返回实际写入的字节数，当有错误发生时则返回-1，错误代码存入errno中。 write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数，特别是在x64环境下，可能会带来一些困扰。在x64环境下，函数的参数是通过寄存器传递的，rdi对应第一个参数，rsi对应第二个参数，rdx对应第三个参数，往往凑不出类似“pop rdi; ret”、“pop rsi; ret”、“pop rdx; ret”等3个传参的gadget。此时，可以考虑使用libc_csu_init函数的通用gadget。简单的说，就是通过libc_csu_init函数的两段代码来实现3个参数的传递，这两段代码普遍存在于x64二进制程序中，只不过是间接地传递参数，而不像原来，是通过pop指令直接传递参数。 举个例子： 这条语句作用是向标准输出中打印&quot;Hello World&quot;它的汇编代码如下： 从上面的代码中可以发现，在write函数被调用(call &lt;write@plt&gt;)之前时，有3个MOV指令，先将write函数的各个参数存入栈中(C语言中参数以从右向左的顺序入栈)。 参数入栈后，执行call指令，call相当于push ip, jmp ，也就是先将IP(函数的返回地址，即下一条指令的地址)压入栈中，然后JMP至被调用函数的地址。 参数入栈后栈的情况如下： call &lt;write&gt;后栈的情况如下： 其中0x08048457为write函数执行完后的返回地址 现在重新梳理一下，调用write函数时依次压入栈中的分别是长度len、数组buf的首地址、文件描述符fd、write函数的返回地址，如下图所示： 那么如果程序中存在缓存区溢出漏洞（比如read函数读取的数据长度比实际缓存区长时)，我们可以通过覆盖函数的返回地址，来控制程序的执行流程。漏洞函数: 我们可以将函数的返回地址覆写为write函数的地址，然后在栈中构造write函数的返回地址和参数，这样我们便可以使用write函数来泄露内存中的信息，比如某函数在libc中的地址等等。 被修改后的栈是这样的： 当正常的函数调用ret指令返回时，ret指令相当于pop eip，也就是说write的地址会赋给eip，相当于执行了一条jmp &lt;write&gt; 现在栈变成了这样: 是不是和上面讲的write函数的栈一样啦？不过也不一样，现在这个栈中的fd,buf,len是我们可以任意指定的。 参考资料： "},{"title":"无libc漏洞利用总结","date":"2019-08-26T12:49:31.000Z","url":"/2019/08/26/%E6%97%A0libc%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/","tags":[["DynELF","/tags/DynELF/"]],"categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"前言通过ROP绕过DEP和ASLR防护，我们要事先得到目标机器上的libc.so或者具体的linux版本号才能计算出相应的offset。在没有目标系统libc文件的情况下，应该如何做呢？这时候就需要通过memory leak(内存泄露)来搜索内存找到system()的地址。，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。通过泄露内存的方式可以获取目标程序libc中各函数的地址，这种攻击方式可以绕过地址随机化保护。下文通过一个例子讨论泄露内存的ROP攻击。 源程序 编译： DynELFDynELF是 pwntools 中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下： 需要使用者进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，address就是leak函数要泄漏信息的所在地址，而payload就是触发目标程序泄漏address处信息的攻击代码。通过这个leak函数可以获取到某个地址上最少1 byte的数据。 使用条件不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件： 1）目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内； 2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息 程序分析read 函数这里显然存在一个缓存区溢出的漏洞，buf的长度是128，read函数读取了256字节的数据，造成了缓冲区溢出。程序example运行的时候由于通过动态链接编译，使用了libc中的函数，我们可以通过 ldd 命令查看程序使用的共享库： ​ 不同的操作系统的libc版本可能不同，不同版本libc中函数的地址也不同。比如system函数在libc 1.9.2 中的位置和libc 2.2.3中的位置不同。可以通过以下命令查看自己操作系统中libc的版本 一般的操作系统默认开启了地址随机化的保护机制(可以通过checksec查看)，程序每次运行的时候，载入到内存中的位置是随机的。如下图，多次使用ldd查看exmaple使用的共享库，可以发现地址已经变化了： 但是程序运行的时候libc已经载入到内存中了，这时libc的地址是一个固定的值，我们可以通过泄露内存的方法dump出程序正在使用的libc，从而找到libc中system函数的地址。 也就是说我们需要构造一个能泄露至少一字节内存的payload： 输入N个字符后发生溢出，write_plt的地址将会覆盖read函数的返回地址，随后程序将会跳转到write函数，我们在栈中构造了write函数的3个参数和返回地址，这段payload相当于让程序执行 write(1, address, 4)这样就可以dump出内存中地址为address处的4字节数据。知道如何从内存中dump数据后，便可以使用pwntools中的DynELF模块查找system函数，并获取system的地址。首先需要确定输入多少字符时，溢出会发生 ，这里可以使用pwntools里面的cyclic工具生成字符串，然后用GDB调试example，找到溢出点，最后，再次使用pwntools中的cyclic查找溢出点距离返回地址的偏移量【通过直接传送大量的字符覆盖返回地址使其在动态调试时报错的方法来确定偏移】： 可以看到，第140字节后的4个字节会覆盖read函数的返回地址，所以泄露system地址的payload如下： 构造leak函数 这段函数能从内存中address处dump出4字节数据，函数执行结束后会返回main函数重新执行，也就是说利用这个函数，我们可以dump出整个libc。 使用DynELF模块查找system函数地址： 获取到system地址后便可以构造system(“&#x2F;bin&#x2F;sh”)攻击程序。要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“&#x2F;bin&#x2F;sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。通过readelf -S example这个命令就可以获取到bss段的地址了。payload如下： 我们构造的read函数有3个参数，这3个参数和read函数的返回地址不同，返回地址在ret指令执行时被pop出栈，但是这3个参数却还留在栈中，没有被弹出栈，这会影响我们构造的下一个函数system的执行，所以我们需要找一个连续pop三个寄存器的指令来平衡堆栈。这种指令很容易找到，如下： 使用字符串过滤的方法即可。 我们找的pop指令后面还需要带有一个ret指令，这样我们平衡堆栈后可以返回到我们构造的函数，如下图所示： 我们可以选取 0x80484f9 - 0x80484fc这四条指令: 形如这样的一串汇编指令也叫作gadgets，在ROP攻击中利用很广泛。gadgets散落在程序汇编代码的各个角落，当程序的代码很长的时候，寻找gadgets就会变得很复杂，因此有人写过工具专门用来寻找程序中的gadgets,比如ROPgadgets。 整个攻击过程如下： ​ 首先通过DynELF获取到system()的地址后，我们又通过read将“/bin/sh”写入到.bss段上，最后再调用system（.bss），执行“&#x2F;bin&#x2F;sh” 攻击脚本 注：ret_addr不能写成是 ret_addr=elf.symbols[&#39;vulnerable_function&#39;]，我刚开始时是这样写的，但总是得不到想要的结果，后来回想起看过的一篇文章，然后改为 ret_addr=elf.symbols[&#39;main&#39;]，结果就行了，据别人说可能是环境变量被覆盖了。 参考资料 "},{"title":"格式化字符串漏洞","date":"2019-08-13T01:56:22.000Z","url":"/2019/08/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"格式化字符串漏洞原理​ 格式化字符串函数将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。一般来说，格式化字符串在利用的时候主要分为三个部分 格式化字符串函数 格式化字符串 后续参数，可选 对于这样的例子，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下 注：这里我们假设 3.14 上面的值为某个未知的值。 假设我们在编写程序时候，写成了下面的样子 程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为 解析其地址对应的字符串 解析其内容对应的整形值 解析其内容对应的浮点值 对于 2，3 来说倒还无妨，但是对于对于 1 来说，如果提供了一个不可访问地址，比如 0，那么程序就会因此而崩溃。这基本就是格式化字符串漏洞的基本原理了。同时也展示了格式化字符串漏洞的两个利用手段 使程序崩溃，因为 %s 对应的参数地址不合法的概率比较大； 查看进程内容，根据 %d，%f 输出了栈上的内容； 程序崩溃利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个 %s 即可 这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。 泄露内存利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作 泄露栈内存 获取某个变量的值 获取某个变量对应地址的内存 泄露任意地址内存 利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址 盲打，dump 整个程序，获取有用信息 简单编译一下后： 获取栈变量数值 使用gdb调试之后的部分截图如下： 程序会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出。 当然，我们也可以使用 %p 来获取数据，如下 这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。 上面给出的方法，都是依次获得栈中的每个参数，我们有没有办法直接获取栈中被视为第 n+1 个参数的值呢？肯定是可以的啦。方法如下 利用上述字符串，我们就可以获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了。 获取栈变量对应字符串获得栈变量对应的字符串，这其实就是需要用到 %s 了。 在第二次执行 printf 函数的时候，确实是将 0xffffcd04 处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。 当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。 小技巧总结 利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。 利用 %s 来获取变量所对应地址的内容，只不过有零截断。 利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容 泄露任意地址内存可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。 一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中 s 是 main 函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个参数的值其实就是该格式化字符串的地址。 那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第 k 个参数。那我们就可以通过如下的方式来获取某个指定地址 addr 的内容。 注： 在这里，如果格式化字符串在栈上，那么我们就一定确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少低于格式化字符串地址 8 字节或者 16 字节。 下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定 重复某个字符的机器字长来作为 tag，而后面会跟上若干个 %p 来输出栈上的内容，如果内容与我们前面的 tag 重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其他字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下 由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第 5 个参数，但是是格式化字符串的第 4 个参数。我们可以来测试一下 可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，所以程序就崩溃了。 补充：获取got表信息的两种方式 1、在gef或pwndbg中运行程序后，输入got即可； 2、使用pwntools中的ELF函数： 覆盖内存上面展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢? 答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型 通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量。 而无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的 payload： 其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤 确定覆盖地址 确定相对偏移 进行覆盖 覆盖栈内存确定覆盖地址首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 ASLR 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。 确定相对偏移其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。 或者输入： 可知格式化字符串相当于 printf 函数的第 7 个参数，相当于格式化字符串的第 6 个参数 进行覆盖这样，第 6 个参数处的值就是存储变量 c 的地址，我们便可以利用 %n 的特征来修改 c 的值。payload 如下 addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。 结果如下： "},{"title":"Linux下的保护机制","date":"2019-08-13T00:06:22.000Z","url":"/2019/08/13/Linux%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"前言在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的code，存在PIE的话各个系统调用的地址就是随机化的。Linux中的保护机制包括canary，NX(no-execute)，PIE(position-independent executables)，RELRO(read only relocation)，FORTIFY等等，暂时没写关于内核安全防护的内容，以后再补充。检查可执行文件属性可使用checksec。 canary栈保护。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址从而控制程序流的执行。当启用栈保护后，函数开始执行的时候会先往栈里插入一个特殊的value值，当函数返回的时候会验证value值是否变化，如果发生变化就停止程序运行。攻击者在覆盖返回地址的时候往往也会将value值给覆盖掉，导致栈保护检查失败而终止程序的执行。这个特殊的value值我们称之为canary。 编译时控制是否开启栈保护及程度的指令： NX:no-execute堆栈不可执行。将数据所在内存页标识为不可执行，当程序执行shellcode中的指令时，CPU就会抛出异常，而不是去执行恶意指令。Linux中的NX与Windows下的DEP工作原理类似，DEP工作原理如下： 控制是否开启NX的指令如下： 注：在Windows下，类似的概念为DEP：Data Execution Prevention（数据执行保护） PIE:position-independent executables位置独立的可执行区域。NX和PIE常常同时工作，这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用ROP技术变得难得多。Windows中的类似机制叫做ASLR：address space layout randomization(内存地址随机化机制)，有以下三种情况： Linux下关闭PIE的命令如下： 编译时的控制指令如下： RELRO:read only relocation只读重定位。在Linux系统中，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以从安全防护的角度来说，尽量减少可写的存储区域对安全会有极大的好处。RELRO让加载器将重定位表中加载时解析的符号标记为只读或在程序启动时就解析并绑定所有动态符号，这减少了GOT覆写攻击的面积。 RELRO可分为： 编译时的控制指令如下： Fortity一种非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsnprintf，gets以及宽字符的变体。开启fortity检查后会替换strcpy等危险函数，由于开销较大，所以默认不开启。 上述两图分别为不启用和启用fortity的截图。对比发现，启用fortity后，程序在执行strcpy函数时，运行了__strcpt_chk函数，这个函数用来检查是否溢出。检查通过后，这个函数会调用strcpy函数。 总结这些安全保护措施极大程度上杜绝了恶意程序的攻击，但大部分情况下有一定缺陷、或需要耗费大量资源。这些保护机制仍需要程序员在操作内存时注意程序的安全问题，如需要严格检查不可信的输入。关于如何绕过这些防护机制，待续。。。 参考资料GCC安全保护机制 linux程序的常用保护机制"}]