[{"title":"Chapter1_IO","date":"2023-07-27T10:36:59.000Z","url":"/2023/07/27/Chapter1_IO/","tags":[["system programming","/tags/system-programming/"]],"categories":[["《系统编程实践（C语言版）》","/categories/%E3%80%8A%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%89%88%EF%BC%89%E3%80%8B/"]],"content":"本章内容主要讲解I&#x2F;O相关函数，文件描述符。 I&#x2F;O是一切实现的基础。 标准I&#x2F;Ofopen(3)fopen()函数用于打开一个文件，并返回一个指向FILE结构体的指针，该结构体包含了关于文件的信息，如文件流、读写位置等，以供后续使用高级文件流进行文件的读写操作。它可以用于创建新文件、打开已存在的文件，并指定文件的打开模式（只读、只写、追加等）。函数原型如下： 参数说明： path：要打开的文件路径的字符串，可以是绝对路径或相对路径。 mode：一个字符串，用来指定文件打开的模式和选项。模式字符串中的字符代表不同的选项，例如”r”表示只读模式，”w”表示只写模式，”a”表示追加模式等。详细的模式选项见下面的说明。 文件打开模式说明： “r“: 只读模式。文件必须存在，否则打开失败。 “r+“: 读写模式。文件必须存在，可以读取和写入。 “w“: 只写模式。如果文件不存在，则创建新文件；如果文件存在，则清空文件内容。 “w+“: 读写模式。如果文件不存在，则创建新文件；如果文件存在，则清空文件内容，可以读取和写入。 “a“: 追加模式。如果文件不存在，则创建新文件；如果文件存在，则在文件末尾追加写入。 “a+“: 读写模式。如果文件不存在，则创建新文件；如果文件存在，则在文件末尾追加读写。 函数返回值： 执行成功时，返回一个指向FILE结构体的指针，指向打开的文件流。如果打开或创建文件成功，该指针非空； 如果打开或创建文件失败，返回值为NULL，表示文件打开失败或者权限不足。 The argument mode points to a string beginning with one of the following sequences (possibly followed by additional characters, as described below): ​ r: Open text file for reading. The stream is positioned at the beginning of the file. ​ r+: Open for reading and writing. The stream is positioned at the beginning of the file. ​ w: Truncate file to zero length or create text file for writing. The stream is positioned at the beginning of the file. ​ w+: Open for reading and writing. The file is created if it does not exist, otherwise it is truncated. The stream is positioned at the beginning of the file. ​ a: Open for appending (writing at end of file). The file is created if it does not exist. The stream is positioned at the end of the file. ​ a+: Open for reading and appending (writing at end of file). The file is created if it does not exist. The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file. beginning of the file：文件打开后第一个有效字节的位置； end of file：文件的最后一个有效字节的下一个位置； 当前位置：读和写都发生在文件的当前位置； 注意事项： （1）fp &#x3D; fopen(“tmp”,”readwrite”)语句中的mode变量效果等价于”r”，“r+write”等价于”r+”。 （2）在调用fopen()函数时，需要确保提供合适的文件打开模式，以防止意外地覆盖或清空原有文件内容。 （3）对于fopen()函数返回的文件指针，在进行文件读写操作后，需要调用fclose()函数来关闭文件流，释放相关资源。 文件I&#x2F;O文件描述符通俗点说，文件描述符就是数组下标，一个整型数。 每个文件都有一个唯一标识inode（就像每个人都有个唯一的身份证号），如果使用open()打开一个文件，会获得一个相关联的结构体，这个结构体中包含了操作该文件时所有必要的信息，就像fopen()打开一个文件会返回一个FILE指针，通过这个指针来进行文件的读写，前面获得的结构体也会有个指针，该指针存放在数组中，交给用户的是存放这个指针的数组的下标，即一个整型数。通过这个整型数找到一个指针，通过这个指针找到一个结构体，通过这个结构体可以操作一个文件。 这个数组有多大？一个进程最多能打开多少个文件，通过ulimit来查看。 一说到stream，其中三个标准的是stdin，stdout，stderr，一说到fd，其中三个标准的是0,1,2。 文件描述符优先使用当前可用范围内最小的。 如果把下标4的内容复制一份放到下标为6的位置，则下标4和下标6对应的两个指针关联的是同一个结构体，如果close(4)，那6那部分还能用吗？如果关联的结构体释放掉了，那下标6的指针就会成为一个野指针。每个结构体当中应该有个计数器，来反映当前结构体被几个指针引用了，如果这个计数器的值不是0，就不free()掉。 open(2)open()函数用于打开一个已存在的文件或者创建一个新文件，函数原型如下： 参数说明： pathname：要打开的文件所在路径的字符串，可以是绝对路径或相对路径。 flags：位图，用来指定文件打开的模式和选项，必须包含以下中的一个：O_RDONLY，O_WRONLY，O_RDWR。如果flags中有O_CREAT，用三参形式的open()，没有的话，就用两参形式的open()。 mode：创建新文件时，该参数用来指定新文件的权限，它是一个八进制数，通常使用 0644 这样的形式。 返回值： 返回一个整型的文件描述符（File Descriptor），代表打开或创建的文件。 如果打开或创建文件成功，将返回非负整数的文件描述符； 如果出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 注意事项： 打开文件成功后，务必在不需要使用文件描述符时及时关闭文件，以防止文件描述符泄漏。 使用open()函数创建文件时，应该在flags中使用O_CREAT选项，并且提供合适的文件权限模式mode，以确保创建的文件具有正确的权限。 在对文件进行读写操作时，建议进行错误检查和适当的错误处理，以应对可能发生的错误情况。 close(2)close()函数用于关闭已打开的文件，释放与之关联的系统资源。函数原型如下： 参数说明： fd：表示要关闭的文件描述符。它是open()，socket()等函数返回的一个整型值。 函数返回值： 执行成功时，返回值为0； 如果出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 read(2)read()函数用于从已打开的文件描述符中读取数据，并将读取的内容存储到指定的缓冲区中。函数原型如下： 参数说明： fd：表示要读取的文件描述符（File Descriptor）。 buf：是一个指向用于存储读取数据的缓冲区的指针。读取的数据将被存储到这个缓冲区中。 count：表示要读取的字节数，即希望从文件中读取的数据量。 函数返回值： read()函数执行成功时，返回实际读取的字节数；（这个值可能小于等于count，因为在某些情况下，可能读取到文件末尾或者发生了错误） 若已到达文件末尾，返回值为0； 若出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 On success, the number of bytes read is returned (zero indicates end of file), and the file position is advanced by this number. It is not an error if this number is smaller than the number of bytes requested; this may happen for example because fewer bytes are actually available right now (maybe because we were close to end-of-file, or because we are reading from a pipe, or from a terminal), or because read() was interrupted by a signal. See also NOTES.On error, -1 is returned, and errno is set appropriately. In this case, it is left unspecified whether the file position (if any) changes.返回值：读到的字节数；若已到达文件尾端，返回0；若出错，返回-1。 注意事项： read()函数是一个阻塞调用，如果没有数据可读，程序会阻塞在该函数处等待数据到达或者出现其他特定的事件。 使用read()函数读取文本文件时，注意文本文件中可能含有换行符\\n，所以在打印输出时可能会换行。如果不需要换行，可以在输出中去掉换行符。 write(2)write()函数用于将数据写入已打开的文件描述符中，将指定的缓冲区数据写入到文件中。函数原型如下： 参数说明： fd：表示要写入的文件描述符。 buf：是一个指向要写入数据的缓冲区的指针。这个缓冲区中的数据将被写入到文件中。 count：表示要写入的字节数，即缓冲区中要写入到文件的数据量。 函数返回值： write()函数执行成功时，返回实际写入的字节数。这个值通常等于count，除非写入遇到错误或遇到了输出限制。 若返回值为-1，表示写入发生错误，并设置全局变量errno来表示具体的错误类型。 On success, the number of bytes written is returned (zero indicates nothing was written). It is not an error if this number is smaller than the number of bytes requested; this may happen for example because the disk device was filled. See also NOTES.On error, -1 is returned, and errno is set appropriately.If count is zero and fd refers to a regular file, then write() may return a failure status if one of the errors below is detected. If no errors are detected, or error detection is not performed, 0 will be returned without causing any other effect. If count is zero and fd refers to a file other than a regular file, the results are not specified.返回值：若成功，返回已写的字节数；若出错，返回-1。 注意事项： write()函数是一个阻塞调用，如果写入操作被阻塞（例如写入缓冲区已满），程序会等待直到能够继续写入或出现其他特定的事件。 当写入数据到文件时，注意文件权限和文件打开模式，确保文件能够正确写入。如果文件权限不足或文件未正确打开，写入操作可能会失败。 lseek(2)lseek()函数用于设置文件的偏移量。程序可以在文件中定位到指定的位置，从而实现对文件的随机访问。函数原型如下： 参数说明： fd：表示要进行偏移设置的文件描述符。 offset：表示要设置的偏移量。它是一个off_t类型的值，可以是正数、负数或零，用于指定相对于whence参数所指定位置的偏移量。 whence：表示偏移量的参考位置，即偏移量的计算方式。它可以取三个值： SEEK_SET：从文件起始位置开始计算偏移量。此时，offset表示从文件起始位置开始的偏移量。 SEEK_CUR：从当前文件读写位置开始计算偏移量。此时，offset表示相对于当前位置的偏移量。 SEEK_END：从文件末尾开始计算偏移量。此时，offset表示相对于文件末尾的偏移量。 函数返回值： 函数执行成功时，返回设置后的文件偏移量。 若设置成功，返回新的文件偏移量，该值通常等于offset参数； 若出现错误，返回值为-1，并设置全局变量errno来表示具体的错误类型。 The lseek() function allows the file offset to be set beyond the end of the file (but this does not change the size of the file). If data is later written at this point, subsequent reads of the data in the gap (a “hole”) return null bytes (‘\\0’) until data is actually written into the gap. Upon successful completion, lseek() returns the resulting offset location as measured in bytes from the beginning of the file. On error, the value (off_t) -1 is returned and errno is set to indicate the error.返回值：若成功，返回新的文件偏移量；若出错，返回-1。 注：off_t类型用于指示文件的偏移量，常就是long类型，其默认为一个32位的整数，在gcc编译中会被编译为long int类型，在64位的Linux系统中则会被编译为long long int，这是一个64位的整数，其定义在unistd.h头文件中可以查看。 注意事项： 对于不支持偏移设置的设备或文件（如终端、管道等），lseek()函数可能不起作用，返回值为-1，并设置errno为ESPIPE错误。"},{"title":"安装破解新版BurpSuite","date":"2021-07-19T12:43:59.000Z","url":"/2021/07/19/%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3%E6%96%B0%E7%89%88BurpSuite/","tags":[["BurpSuite","/tags/BurpSuite/"]],"categories":[["软件激活","/categories/%E8%BD%AF%E4%BB%B6%E6%BF%80%E6%B4%BB/"]],"content":"新发布的BurpSuite界面看着更舒适，也增加了一些新功能，下面记录的是BurpSuite 2020.12专业版的安装过程。（实测2021.7也可以用同样方式安装激活） 注：jdk 8环境下会出现闪退现象，jdk 16环境下会出现如下图所示问题： 建议安装jdk 11。原有Java版本卸载可参考如下：  版本11之后的jdk如下图所示没有jre文件，可以通过如下方式生成： 通过管理员权限运行cmd命令之后，进入jdk的安装目录，然后执行以下指令： 接下来配置环境变量， Jdk 11安装成功之后，运行安装包里的run.bat文件，结果如下： License key可通过License KeyGen.jar文件生成。点击运行License KeyGen.jar结果如下： 将上图红框中的字符串复制粘贴，之后点击“Next” 接着点击如下图中的“Manual activation”， 将自动生成的Activation Response复制粘贴即可： 可以看到BurpSuite的有效期至2091年，近乎永久有效。 注：关闭BurpSuite软件后，下次要使用时直接点击运行run.bat文件即可"},{"title":"floor报错注入原理分析","date":"2021-07-15T02:56:08.000Z","url":"/2021/07/15/floor%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"引子​ 最近工作中遇到了floor报错注入的相关知识，网上找到的文章有蛮多写得都不错，从原理到一些细节讲得都很到位，把它们总结归纳一下，于是就有了这篇文章。 报错的条件​ floor报错注入是指利用 select count(*) from table group by floor(rand(0)*2) 构造特定的语句导致数据库查询错误，从而实现在报错信息中显示攻击者希望看到的数据。其它语句，例如select count(*),(floor(rand(0)*2))x from table group by x;可以看做是它的变形。 ​ 在上面的情况下它报错了，但是不是任何情况下都会导致报错呢？ ​ 我们先来试试books表中只有一条记录的情况下，该语句会不会报错？多次执行结果均如下图所示： ​ 没有报错，再增加一条语句试试看，多次执行的结果均是如下图所示： ​ 没有报错，继续增加一条记录，当表中有三条记录时，看看结果如何？多次执行结果均是如下图所示： ​ 成功报错，而且不管你执行多少次，结果都是一样的。由此可见，select count(*) from table group by floor(rand(0)*2) 语句报错是有条件的，记录必须至少有3条，那问题来啦，原理何在呢？继续往下看。 随机因子起作用么？​ 来看看报错原因与随机因子的联系，把随机因子去掉，再按照上面的过程试一遍。先看一条记录的情况，多次执行结果均如下图所示： ​ 没有报错，再增加一条语句试试看，多次执行的结果如下图所示： ​ 两条记录的情况下，结果就变得不确定了，可能报错，也可能不报错。三条记录的情况与两条记录一样，结果也是不确定的。 ​ 由此可见，报不报错和随机因子是有关联的，但是有什么关联呢？为什么直接使用rand()，有两条记录的情况下就会报错，而且是有时候报错，有时候不报错，而rand(0)的时候在两条的时候不报错，在三条以上就绝对报错？我们继续往下看。 group by与count(*)​ group by主要用来对数据进行分组，相同的分为一组，常与count()结合使用。在此，我们需要明白分组计数的过程中发生了什么。这个过程中会建立一个有两个字段的虚拟表，一个是分组的 key ，一个是计数值 count(*)。在查询数据的时候，首先查看该虚拟表中是否存在该分组，如果存在那么计数值加1，不存在则新建该分组。 floor(rand(0)*2)MySQL官网上这样写着： The RAND() function in MySQL is used to a return random floating-point value V in the range 0 &lt;&#x3D; V &lt; 1.0. Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. ​ MySQL官方所说到的“be evaluated multiple times”就是说使用group by的时，查询过程中floor(rand(0)*2)会被执行一次，如果虚表不存在记录，插入虚表的时候会再被执行一次。 Wooyun知识库里T-Safe团队这样写着： RAND() in a WHERE clause is re-evaluated every time the WHERE is executed. You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times. ​ rand()可以产生一个[0,1)之间的随机数，当提供一个参数因子0后，rand(0)每次产生的“随机数”都是确定的。 ​ floor()返回小于等于该值的最大整数，rand()*2返回的是[0,2)之间的随机数，再配合floor()就可以产生两个确定的数，即0和1。floor(rand(0)*2)会产生一个确定的01序列（以下内容来源于一个拥有7条记录的表）：0110110…… 报错分析floor(rand(0)*2)报错​ group by 进行分组时，floor(rand(0)*2)执行一次（查看分组是否存在），如果虚拟表中不存在该分组，那么在插入新分组的时候 floor(rand(0)*2) 就又计算了一次。下面来具体看看select count(*) from table group by floor(rand(0)*2) 的查询过程： （1）查询前默认会建立如下空虚拟表： （2）取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算)，查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕，结果如下： （3）查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕，结果如下： （4）查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 （5）整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 floor(rand()*2)报错​ 在没加入随机因子的情况下，floor(rand()*2)是不可测的，因此可能报错，也可能不报错。在两条记录的情况下，只要出现如下情况，即可报错： ​ 最重要的是前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()*2)不会再被计算做为虚表的键值，这也就是为什么不加随机因子有时候会报错，有时候不会报错的原因。 ​ 当前面记录让虚表长成如下图这样子后，由于不管查询多少条记录，floor(rand()*2)的值在虚表中都能找到，所以不会被再次计算，只是简单的增加count(*)字段的数量，所以不会报错，比如floor(rand(1)*2)： ​ 在前两条记录查询后，虚拟表已经存在0和1两个键值了，所以后面再怎么弄还是不会报错。总之报错需要count(*)，rand()、group by，三者缺一不可。 ​ floor(rand(0)*2的作用就是产生预知的数字序列0110110...，然后再利用 rand() 的特殊性和group by的虚拟表，最终引起了报错。 利用方式​ floor报错注入的原因是group by在向临时表插入数据时，由于rand()多次计算导致插入临时表时主键重复，从而报错，又因为报错前concat()中的SQL语句或函数被执行，所以该语句报错且被抛出的主键是SQL语句或函数执行后的结果。 ​ floor报错注入的利用，通俗点说就是利用concat()构造特殊的主键，当主键值不唯一时就报错并回显该主键值，主键值中就包含着我们想要的内容。下面以本地搭建的实验环境为例，介绍相关利用方式。 爆库 ​ 由于 and 后要跟1或者0，所以构造sql语句select 1 。 爆表 爆列 爆字段 总结​ 在写这篇文章的过程中，理解了floor函数报错的条件，报错的原理以及利用方式。总的来说，还是深感专业技能的不足，还需要加强学习。 参考资料Mysql报错注入原理分析(count()、rand()、group by) mysql的floor()报错注入方法详细分析"},{"title":"CentOS 7配置SSH免密登录","date":"2021-07-14T11:49:50.000Z","url":"/2021/07/14/CentOS%207%E9%85%8D%E7%BD%AESSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/","tags":[["SSH免密登录","/tags/SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"]],"categories":[["undefined",""]],"content":"先在CentOS 7中配置固定IP地址，然后实现两台主机之间相互SSH免密登录。 CentOS 7 配置固定IPCentOS 7系统配置固定IP地址（192.168.111.135）的四个步骤如下： （1）配置虚拟机NAT模式的地址参数 （2）配置本机VMnet8地址参数 （3）修改CentOS 7固定IP的配置文件 （4）重启网络服务 （5）验证结果 配置SSH免密登录（1）生成密钥对 CentOS 7默认使用RSA加密算法生成密钥对，保存在~&#x2F;.ssh目录下为id_rsa（私钥）和id_rsa.pub（公钥），密钥对生成过程中会提示输入私钥加密密码，直接回车就行。 （2）移动id_rsa.pub文件 以同样的方式在192-168-111-135中生成相应密钥对，然后将192-168-111-134的公钥移动到192-168-111-135的&#x2F;root&#x2F;.ssh文件夹下： （3）验证免密登录 上面结果表明，192-168-111-134机器成功通过SSH免密登录了192-168-111-135机器，配置成功。后面配置192-168-111-135免密登录192-168-111-134情况类似。"},{"title":"DC靶机","date":"2019-09-05T18:25:31.000Z","url":"/2019/09/06/DC%E9%9D%B6%E6%9C%BA/","categories":[["渗透测试","/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"]],"content":"前言将近一年没玩Web，没玩渗透了，企业来学校培训教了点Web安全的姿势(不教二进制，有点失望！！！后来问了下，原来是半路出家的，不会 (滑稽 )，教的时候，是用DC靶机中的DC-4，做完实验后，干脆写个博客算了，就当是玩玩，慢慢地也会把其它几个补全来。下载地址 正菜前的甜点1）安装DC-4靶机：直接用VMware打开DC-4.ova文件，导入到相应文件夹即可； 2）将Kali与靶机设置为同一网段：VMware–虚拟机–设置–网络适配器–仅主机模式 3）获取目标主机的IP地址：首先获取Kali的IP地址为192.168.208.129，再寻找同网段内的其他主机的IP地址，一个个排除，直到找到目标主机的地址为192.168.208.131 正菜在浏览器中访问该地址后，发现一个登入框： 使用burp爆破，用Kali自带的两个字典中较小的那一个即可【Kali中自带了两个字典，一大一小为别为：&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz；&#x2F;usr&#x2F;share&#x2F;john&#x2F;password.lst】，发现用户名为admin，密码为happy，登入后结果如下： 可以看到能够执行ls -l, du -h,df -h这三个命令，猜测可能存在命令注入漏洞，修改radio参数，可以看到有三个用户名 ，及各用户名下的相应文件，其中有个/home/jim/backups/old-passwords.bak文件，通过cat命令可以获得其内容： 考虑到目标主机还开启了22端口，也许是要我们使用ssh登入，因此，使用hydra爆破，将charles，jim，sam写入用户名字典user.txt中，将old-passwords.bak中的内容作为密码字典old-password.txt，爆破结果如下： 可以发现jim的ssh登入密码为：jibril04。使用该密码登入：ssh jim@192.168.208.131，登入后打印mbox文件 给人的第一印象就是，这是封邮件，因此，我们转到/var/mail目录下，发现也有个jim文件，打印结果为： 将用户从jim切换为charles，还发现charles貌似权限不够 查看用户权限，发现该用户可以以root权限免密码执行 /usr/bin/teehee 提权时，我们可以选择用定时器提权，或者是篡改 passwd写入一个具有root权限的伪用户进行get root 选择添加一个f1yingf0x用户，并使用teehee执行写入 passwd中（也可以选择通过teehee的sudo提升权限以root身份写入crontab计划任务通过执行获取root权限） 获得root权限后，打印root目录下的flag.txt文件，获得最终的结果： 参考资料DC-4渗透实战"},{"title":"深入理解GOT表覆写技术","date":"2019-09-05T15:01:04.000Z","url":"/2019/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GOT%E8%A1%A8%E8%A6%86%E5%86%99%E6%8A%80%E6%9C%AF/","tags":[["ELF","/tags/ELF/"],["共享库","/tags/%E5%85%B1%E4%BA%AB%E5%BA%93/"],["动态链接","/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"]],"categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"前言玩pwn的时候，有时要用到got表覆写技术，本文在于分享对GOT表覆写技术的理解，铺垫性的基础知识较多，目的在于让初学者知其然，还要知其所以然！ ELF文件生成过程 注：gcc命令实际上是具体程序（如ccp、cc1、as等）的包装命令，用户通过gcc命令来使用具体的预处理程序ccp、编译程序cc1和汇编程序as等。 预处理过程主要处理源文件中以“#”开头的预编译指令，经过预编译处理后，得到的是预处理文件（如，hello.i) ，它还是一个可读的文本文件 。 编译过程将预处理后得到的预处理文件（如 hello.i）进行词法分析、语法分析、语义分析、优化后，生成汇编代码文件。经过编译后，得到的汇编代码文件（如 hello.s）还是可读的文本文件，CPU无法理解和执行它。 汇编过程汇编程序（汇编器）用来将汇编语言源程序转换为机器指令序列（机器语言程序）。汇编结果是一个可重定位目标文件（如 hello.o），其中包含的是不可读的二进制代码，必须用相应的工具软件来查看其内容。 预处理、编译和汇编三个过程针对一个模块（一个*.c文件）进行处理，得到对应的一个可重定位目标文件（一个*.o文件）。 链接过程将多个可重定位目标文件合并以生成可执行目标文件 目标文件格式概述三类目标文件1、可重定位目标文件 (Relocatable File; 后缀名为“.o”) 2、可执行目标文件(Executable File；一般没有后缀名) 3、共享的目标文件 (Shared Object File；后缀名为“.so”) 标准的几种目标文件格式 DOS操作系统（最简单） ：COM格式，文件中仅包含代码和数据，且被加载到固定位置； System V UNIX早期版本：COFF格式，文件中不仅包含代码和数据，还包含重定位信息、调试信息、符号表等其他信息，由一组严格定义的数据结构序列组成； Windows： PE格式（COFF的变种），称为可移植可执行(Portable Executable，简称PE)；4)Linux等类UNIX：ELF格式（COFF的变种），称为可执行可链接(Executable and Linkable Format，简称ELF)； 两种视图链接视图（被链接）：可重定位目标文件(Relocatable object files) 执行视图（被执行）：可执行目标文件（Executable object files） ELF可重定位目标文件 .bss 节 ELF可执行目标文件 符号及符号表链接操作的步骤 Step 1. 符号解析（Symbol resolution） Step 2. 重定位 链接符号的类型每个可重定位目标模块m都有一个符号表，它包含了在m中定义和引用的符号。有三种链接器符号： 目标文件中的符号表 静态链接和符号解析静态链接对象多个可重定位目标模块 + 静态库（标准库、自定义库）（.o文件） （.a文件，其中包含多个.o模块）静态库 (.a archive files) 自定义一个静态库文件 链接器中符号解析的全过程三个重要集合：E 将要被合并以组成可执行文件的所有目标文件集合U 当前所有未解析的引用符号的集合D 当前所有定义符号的集合 开始E、U、D为空，首先扫描main.o，把它加入E，同时把Function加入U，main加入D。接着扫描到mylib.a，将U中所有符号(本例中为Function)与mylib.a中所有目标模块(program1.o和program2.o)依次匹配，发现在program1.o中定义了Function，故program1.o加入E，Function从U转移到D。在program1.o中发现还有未解析符号printf，将其加到U。不断在mylib.a的各模块上进行迭代以匹配U中的符号，直到U、D都不再变化。此时U中只有一个未解析符号printf，而D中有main和Function。因为模块program2.o没有被加入E中，因而它被丢弃。接着，扫描默认的库文件libc.a，发现其目标模块printf.o定义了printf，于是printf也从U移到D，并将printf.o加入E，同时把它定义的所有符号加入D，而所有未解析符号加入U。处理完libc.a时，U一定是空的。 注:被链接模块应按调用顺序指定！若命令为： 首先，扫描mylib，因是静态库，应根据其中是否存在U中未解析符号对应的定义符号来确定哪个.o被加入E。因为开始U为空，故其中两个.o模块都不被加入E中而被丢弃。然后，扫描main.o，将Function加入U，直到最后它都不能被解析,因此，出现链接错误，因为它只能用mylib.a中符号来解析，而mylib中两个.o模块都已被丢弃！ 可执行文件的加载通过调用execve系统调用函数来调用加载器： execve()函数的用法如下： filename是加载并运行的可执行文件名(如./hello)，可带参数列表argv和环境变量列表envp。若错误（如找不到指定文件filename），则返回-1，并将控制权交给调用程序； 若函数执行成功，则不返回，最终将控制权传递到可执行目标中的主函数main。 主函数main()的原型形式如下： argc指定参数个数，参数列表中第一个总是命令名（可执行文件名） hello程序的加载和运行过程 共享库和动态链接【划重点】静态库有一些缺点 解决方案: Shared Libraries （共享库） 自定义一个动态共享库文件 地址无关代码【划重点】• 动态链接用到一个重要概念：我们希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本想法就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就叫做**地址无关代码（Position-Independent Code，PIC)**。 • 共享库代码是一种PIC • 所有引用情况 要实现动态链接，必须生成PIC代码，要生成PIC代码，主要解决第3和第4这两个问题 （1）模块内的函数调用或跳转 调用或跳转源与目的地都在同一个模块，相对位置固定，只要用相对偏移寻址即可。call的目标地址为：0x8048369 + 0xffffffdb(-0x25) &#x3D; 0x8048344注： 该指令是一条近址相对位移调用指令（2）模块内的数据引用 注：任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，那么只要相对于当前指令加上固定的偏移量就可以访问模块内部的数据了。 变量a与引用a的指令之间的距离为常数，调用__get_pc后，call指令的返回地址被置ECX。若模块被加载到0x9000000，则a的访问地址为：0x9000000+0x34c+0x118c(指令与.data间距离)+0x28(a在.data节中偏移) （3）模块间的数据访问ELF解决模块间的数据访问目标地址的做法是在数据段里面建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table,Got）,当代码需要引用该全局变量时，可通过GOT中相对应的项间接引用。模块在编译时可以确定GOT相对于当前指令的偏移，然后根据变量地址在GOT中的偏移就可得到变量的地址。比如，当指令要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。 （4）模块间的调用、跳转同理，我们可以使用类似于模块间的数据访问的方式，在GOT中加一个项(指针)，用于指向目标函数的首地址（如&amp;ext），但是也要多用三条指令并额外多用一个寄存器（如EBX）。因此，可用“延迟绑定（lazy binding）”技术来优化动态链接性能：当函数第一次被用到时才进行绑定（符号查找、重定位等），这样可以大大加快程序启动速度。ELF使用PLT（Procedure linkage Table, 过程链接表)的方法来实现。通常我们调用某个外部模块的函数时，应该是通过GOT中相应的项进行间接跳转。而PLT为了实现延迟绑定，在这个过程中有增加了一层间接跳转。调用函数并不直接通过GOT跳转，而是通过一个叫作PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项，比如bar()在PLT中的项的地址我们称为bar@plt。其中bar@plt的实现如下： 第一条指令是通过一条GOT间接跳转的指令。bar@GOT表示GOT中保存的bar()这个函数相应的项。链接器在初始化阶段没有将bar()的地址填入到该项中，而是将上面代码中第二条指令“push n”的地址填入到bar@GOT中。显然，第一条指令的效果是跳转到第二条指令，第二条指令将一个数字n压入堆栈中，该数字为bar这个符号引用在重定位表“.rel.plt”中的下标。接着将模块的ID压入堆栈中，然后调用_dl_runtime_resolve函数来完成符号解析和重定位工作。_dl_runtime_resolve在进行一系列工作以后将bar()的真正地址填入到bar@GOT中。再次调用bar@plt时，第一条jump指令能跳转到真正的bar()函数中，bar()函数返回的时候会根据堆栈里保存的EIP直接返回到调用者，而不会在继续执行bar@plt中第二条指令开始的那段代码。ELF将GOT拆分为两个表叫做“.got”和“.got.plt”: 注：Linux下，ELF可执行文件虚拟地址空间默认从地址0x08048000开始分配 实践部分理解了何为GOT表和PLT之后，我们再通过pwnable.kr中的题目passcode来介绍一下GOT表覆盖技术： 解题思路:由于welcome()和login()函数调用栈的EBP相同，通过gdb调试后可以发现 输入的变量没有用取地址符号&amp;，导致读入数据的时候，scanf会把这个变量中的值当成存储地址来存放数据，name值的最后4个字节是passcode1值，所以可以通过将passcode1的值改为fflush()的地址，scanf()之后会调用fflush()函数，覆盖fflush()在GOT表中的内容，把system(“/bin/cat flag”)对应汇编代码地址写入fflush()中，当这个函数被调用时，就会直接执行system(“/bin/cat flag”)。 通过objdump -R passcode命令查看GOT表可以发现fflush()位于0x0804a004处，即将0x80485e3（调用system的地址）覆写位于0x0804a004的fflush()函数的GOT表。 参考资料《程序员的自我修养》《计算机系统基础(一)：程序的表示、转换与链接》 注：本文首发于安全客 "},{"title":"write函数","date":"2019-08-26T12:52:54.000Z","url":"/2019/08/26/write%E5%87%BD%E6%95%B0/","categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"下面介绍下write这个普遍用来泄漏信息的函数： write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。如果顺利，write()会返回实际写入的字节数，当有错误发生时则返回-1，错误代码存入errno中。 write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数，特别是在x64环境下，可能会带来一些困扰。在x64环境下，函数的参数是通过寄存器传递的，rdi对应第一个参数，rsi对应第二个参数，rdx对应第三个参数，往往凑不出类似“pop rdi; ret”、“pop rsi; ret”、“pop rdx; ret”等3个传参的gadget。此时，可以考虑使用libc_csu_init函数的通用gadget。简单的说，就是通过libc_csu_init函数的两段代码来实现3个参数的传递，这两段代码普遍存在于x64二进制程序中，只不过是间接地传递参数，而不像原来，是通过pop指令直接传递参数。 举个例子： 这条语句作用是向标准输出中打印&quot;Hello World&quot;它的汇编代码如下： 从上面的代码中可以发现，在write函数被调用(call &lt;write@plt&gt;)之前时，有3个MOV指令，先将write函数的各个参数存入栈中(C语言中参数以从右向左的顺序入栈)。 参数入栈后，执行call指令，call相当于push ip, jmp ，也就是先将IP(函数的返回地址，即下一条指令的地址)压入栈中，然后JMP至被调用函数的地址。 参数入栈后栈的情况如下： call &lt;write&gt;后栈的情况如下： 其中0x08048457为write函数执行完后的返回地址 现在重新梳理一下，调用write函数时依次压入栈中的分别是长度len、数组buf的首地址、文件描述符fd、write函数的返回地址，如下图所示： 那么如果程序中存在缓存区溢出漏洞（比如read函数读取的数据长度比实际缓存区长时)，我们可以通过覆盖函数的返回地址，来控制程序的执行流程。漏洞函数: 我们可以将函数的返回地址覆写为write函数的地址，然后在栈中构造write函数的返回地址和参数，这样我们便可以使用write函数来泄露内存中的信息，比如某函数在libc中的地址等等。 被修改后的栈是这样的： 当正常的函数调用ret指令返回时，ret指令相当于pop eip，也就是说write的地址会赋给eip，相当于执行了一条jmp &lt;write&gt; 现在栈变成了这样: 是不是和上面讲的write函数的栈一样啦？不过也不一样，现在这个栈中的fd,buf,len是我们可以任意指定的。 参考资料： "},{"title":"无libc漏洞利用总结","date":"2019-08-26T12:49:31.000Z","url":"/2019/08/26/%E6%97%A0libc%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/","tags":[["DynELF","/tags/DynELF/"]],"categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"前言通过ROP绕过DEP和ASLR防护，我们要事先得到目标机器上的libc.so或者具体的linux版本号才能计算出相应的offset。在没有目标系统libc文件的情况下，应该如何做呢？这时候就需要通过memory leak(内存泄露)来搜索内存找到system()的地址。，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。通过泄露内存的方式可以获取目标程序libc中各函数的地址，这种攻击方式可以绕过地址随机化保护。下文通过一个例子讨论泄露内存的ROP攻击。 源程序 编译： DynELFDynELF是 pwntools 中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下： 需要使用者进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，address就是leak函数要泄漏信息的所在地址，而payload就是触发目标程序泄漏address处信息的攻击代码。通过这个leak函数可以获取到某个地址上最少1 byte的数据。 使用条件不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件： 1）目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内； 2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息 程序分析read 函数这里显然存在一个缓存区溢出的漏洞，buf的长度是128，read函数读取了256字节的数据，造成了缓冲区溢出。程序example运行的时候由于通过动态链接编译，使用了libc中的函数，我们可以通过 ldd 命令查看程序使用的共享库： ​ 不同的操作系统的libc版本可能不同，不同版本libc中函数的地址也不同。比如system函数在libc 1.9.2 中的位置和libc 2.2.3中的位置不同。可以通过以下命令查看自己操作系统中libc的版本 一般的操作系统默认开启了地址随机化的保护机制(可以通过checksec查看)，程序每次运行的时候，载入到内存中的位置是随机的。如下图，多次使用ldd查看exmaple使用的共享库，可以发现地址已经变化了： 但是程序运行的时候libc已经载入到内存中了，这时libc的地址是一个固定的值，我们可以通过泄露内存的方法dump出程序正在使用的libc，从而找到libc中system函数的地址。 也就是说我们需要构造一个能泄露至少一字节内存的payload： 输入N个字符后发生溢出，write_plt的地址将会覆盖read函数的返回地址，随后程序将会跳转到write函数，我们在栈中构造了write函数的3个参数和返回地址，这段payload相当于让程序执行 write(1, address, 4)这样就可以dump出内存中地址为address处的4字节数据。知道如何从内存中dump数据后，便可以使用pwntools中的DynELF模块查找system函数，并获取system的地址。首先需要确定输入多少字符时，溢出会发生 ，这里可以使用pwntools里面的cyclic工具生成字符串，然后用GDB调试example，找到溢出点，最后，再次使用pwntools中的cyclic查找溢出点距离返回地址的偏移量【通过直接传送大量的字符覆盖返回地址使其在动态调试时报错的方法来确定偏移】： 可以看到，第140字节后的4个字节会覆盖read函数的返回地址，所以泄露system地址的payload如下： 构造leak函数 这段函数能从内存中address处dump出4字节数据，函数执行结束后会返回main函数重新执行，也就是说利用这个函数，我们可以dump出整个libc。 使用DynELF模块查找system函数地址： 获取到system地址后便可以构造system(“&#x2F;bin&#x2F;sh”)攻击程序。要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“&#x2F;bin&#x2F;sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。通过readelf -S example这个命令就可以获取到bss段的地址了。payload如下： 我们构造的read函数有3个参数，这3个参数和read函数的返回地址不同，返回地址在ret指令执行时被pop出栈，但是这3个参数却还留在栈中，没有被弹出栈，这会影响我们构造的下一个函数system的执行，所以我们需要找一个连续pop三个寄存器的指令来平衡堆栈。这种指令很容易找到，如下： 使用字符串过滤的方法即可。 我们找的pop指令后面还需要带有一个ret指令，这样我们平衡堆栈后可以返回到我们构造的函数，如下图所示： 我们可以选取 0x80484f9 - 0x80484fc这四条指令: 形如这样的一串汇编指令也叫作gadgets，在ROP攻击中利用很广泛。gadgets散落在程序汇编代码的各个角落，当程序的代码很长的时候，寻找gadgets就会变得很复杂，因此有人写过工具专门用来寻找程序中的gadgets,比如ROPgadgets。 整个攻击过程如下： ​ 首先通过DynELF获取到system()的地址后，我们又通过read将“/bin/sh”写入到.bss段上，最后再调用system（.bss），执行“&#x2F;bin&#x2F;sh” 攻击脚本 注：ret_addr不能写成是 ret_addr=elf.symbols[&#39;vulnerable_function&#39;]，我刚开始时是这样写的，但总是得不到想要的结果，后来回想起看过的一篇文章，然后改为 ret_addr=elf.symbols[&#39;main&#39;]，结果就行了，据别人说可能是环境变量被覆盖了。 参考资料 "},{"title":"格式化字符串漏洞","date":"2019-08-13T01:56:22.000Z","url":"/2019/08/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"格式化字符串漏洞原理​ 格式化字符串函数将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。一般来说，格式化字符串在利用的时候主要分为三个部分 格式化字符串函数 格式化字符串 后续参数，可选 对于这样的例子，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下 注：这里我们假设 3.14 上面的值为某个未知的值。 假设我们在编写程序时候，写成了下面的样子 程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为 解析其地址对应的字符串 解析其内容对应的整形值 解析其内容对应的浮点值 对于 2，3 来说倒还无妨，但是对于对于 1 来说，如果提供了一个不可访问地址，比如 0，那么程序就会因此而崩溃。这基本就是格式化字符串漏洞的基本原理了。同时也展示了格式化字符串漏洞的两个利用手段 使程序崩溃，因为 %s 对应的参数地址不合法的概率比较大； 查看进程内容，根据 %d，%f 输出了栈上的内容； 程序崩溃利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们只需要输入若干个 %s 即可 这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。 泄露内存利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作 泄露栈内存 获取某个变量的值 获取某个变量对应地址的内存 泄露任意地址内存 利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址 盲打，dump 整个程序，获取有用信息 简单编译一下后： 获取栈变量数值 使用gdb调试之后的部分截图如下： 程序会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出。 当然，我们也可以使用 %p 来获取数据，如下 这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。 上面给出的方法，都是依次获得栈中的每个参数，我们有没有办法直接获取栈中被视为第 n+1 个参数的值呢？肯定是可以的啦。方法如下 利用上述字符串，我们就可以获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了。 获取栈变量对应字符串获得栈变量对应的字符串，这其实就是需要用到 %s 了。 在第二次执行 printf 函数的时候，确实是将 0xffffcd04 处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。 当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。 小技巧总结 利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。 利用 %s 来获取变量所对应地址的内容，只不过有零截断。 利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容 泄露任意地址内存可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。 一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中 s 是 main 函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个参数的值其实就是该格式化字符串的地址。 那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第 k 个参数。那我们就可以通过如下的方式来获取某个指定地址 addr 的内容。 注： 在这里，如果格式化字符串在栈上，那么我们就一定确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少低于格式化字符串地址 8 字节或者 16 字节。 下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定 重复某个字符的机器字长来作为 tag，而后面会跟上若干个 %p 来输出栈上的内容，如果内容与我们前面的 tag 重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其他字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下 由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第 5 个参数，但是是格式化字符串的第 4 个参数。我们可以来测试一下 可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，所以程序就崩溃了。 补充：获取got表信息的两种方式 1、在gef或pwndbg中运行程序后，输入got即可； 2、使用pwntools中的ELF函数： 覆盖内存上面展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢? 答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型 通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量。 而无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的 payload： 其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤 确定覆盖地址 确定相对偏移 进行覆盖 覆盖栈内存确定覆盖地址首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 ASLR 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。 确定相对偏移其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()。 这里我们通过之前的泄露栈变量数值的方法来进行操作。 或者输入： 可知格式化字符串相当于 printf 函数的第 7 个参数，相当于格式化字符串的第 6 个参数 进行覆盖这样，第 6 个参数处的值就是存储变量 c 的地址，我们便可以利用 %n 的特征来修改 c 的值。payload 如下 addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。 结果如下： "},{"title":"Linux下的保护机制","date":"2019-08-13T00:06:22.000Z","url":"/2019/08/13/Linux%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","categories":[["二进制","/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"]],"content":"前言在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了NX、PIE等机制，例如存在NX的话就不能直接执行栈上的code，存在PIE的话各个系统调用的地址就是随机化的。Linux中的保护机制包括canary，NX(no-execute)，PIE(position-independent executables)，RELRO(read only relocation)，FORTIFY等等，暂时没写关于内核安全防护的内容，以后再补充。检查可执行文件属性可使用checksec。 canary栈保护。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址从而控制程序流的执行。当启用栈保护后，函数开始执行的时候会先往栈里插入一个特殊的value值，当函数返回的时候会验证value值是否变化，如果发生变化就停止程序运行。攻击者在覆盖返回地址的时候往往也会将value值给覆盖掉，导致栈保护检查失败而终止程序的执行。这个特殊的value值我们称之为canary。 编译时控制是否开启栈保护及程度的指令： NX:no-execute堆栈不可执行。将数据所在内存页标识为不可执行，当程序执行shellcode中的指令时，CPU就会抛出异常，而不是去执行恶意指令。Linux中的NX与Windows下的DEP工作原理类似，DEP工作原理如下： 控制是否开启NX的指令如下： 注：在Windows下，类似的概念为DEP：Data Execution Prevention（数据执行保护） PIE:position-independent executables位置独立的可执行区域。NX和PIE常常同时工作，这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用ROP技术变得难得多。Windows中的类似机制叫做ASLR：address space layout randomization(内存地址随机化机制)，有以下三种情况： Linux下关闭PIE的命令如下： 编译时的控制指令如下： RELRO:read only relocation只读重定位。在Linux系统中，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以从安全防护的角度来说，尽量减少可写的存储区域对安全会有极大的好处。RELRO让加载器将重定位表中加载时解析的符号标记为只读或在程序启动时就解析并绑定所有动态符号，这减少了GOT覆写攻击的面积。 RELRO可分为： 编译时的控制指令如下： Fortity一种非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsnprintf，gets以及宽字符的变体。开启fortity检查后会替换strcpy等危险函数，由于开销较大，所以默认不开启。 上述两图分别为不启用和启用fortity的截图。对比发现，启用fortity后，程序在执行strcpy函数时，运行了__strcpt_chk函数，这个函数用来检查是否溢出。检查通过后，这个函数会调用strcpy函数。 总结这些安全保护措施极大程度上杜绝了恶意程序的攻击，但大部分情况下有一定缺陷、或需要耗费大量资源。这些保护机制仍需要程序员在操作内存时注意程序的安全问题，如需要严格检查不可信的输入。关于如何绕过这些防护机制，待续。。。 参考资料GCC安全保护机制 linux程序的常用保护机制"}]